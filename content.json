{"meta":{"title":"Yisin's Blog","subtitle":null,"description":"可爱的Yisin呀","author":"Yisin","url":""},"pages":[{"title":"Yisin二三事","date":"2018-12-04T01:11:25.000Z","updated":"2020-02-12T09:35:40.126Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"生于浙江，长于浙江，冀北求学ing 真名XYX，但是大家一般叫我Yisin 是个蠢但是自带可爱属性的小仙女。 来自NEUQ的小菜鸡。梦想是成为wls那样的人。 平生所好，唯诗书与代码而已矣。 最喜欢的作家是书海沧生。 她的《昭奚旧草》、《十年一品温如言》、《同学录》都看了好多好多遍。 她能写尽世间一切求而不得。得之我幸，失之我命。 现在有一个非常非常喜欢的男朋友~他很厉害，但是是我的！ 兔兔，要是世上只有我们两个人多么好，我一定要把你欺负得哭不出来。 安安静静地读书，心无旁骛地敲代码。 如果你也有梦想，不妨一起来白日做梦吧！ QQ：997214586 E-mail：997214586@qq.com 最好的年华，和最美好的自己相遇 这里是一只喜欢敲代码、喜欢写诗词、喜欢破产三姐妹的CuteYisin小仙女"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-02-11T10:30:27.306Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-11T10:15:17.459Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-11T09:49:37.179Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"dp专题解题报告","slug":"dp专题解题报告","date":"2020-10-05T12:37:19.000Z","updated":"2020-10-09T12:31:09.847Z","comments":true,"path":"2020/10/05/dp专题解题报告/","link":"","permalink":"/2020/10/05/dp专题解题报告/","excerpt":"","text":"dp专题解题报A - Number of Subsequences题意是给你一个含有’a’ ‘b’ ‘c’和’?’的字符串，’?’处可任意填入单个’a’ ‘b’或’c’。问所有排列组合中有多少个子序列包含”abc”。 可以列出一个二维的dp数组dp[i][j]，表示在i处前有多少个包含a/ab/abc的子序列。 dp[i][0]表示前i个字符中序列总数。每遇到一个’?’，序列数变为三倍。 dp[i][1]的转移只需要根据当前位置若为a，则dp[i][1]累加上序列总数； dp[i][2]的转移根据当前位置是否为b，为b则转移为dp[i-1][2]+dp[i-1][1]； dp[i][3]的转移根据当前位置是否为c，为c则转移为dp[i-1][3]+dp[i-1][2]； 若i处为’?’，则可以表示上述所有情况，并且每种情况递推为当前的三倍加上相应的值。 具体代码如下： #include&lt;bits/stdc++.h&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;math.h&gt; #include &lt;bitset&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} const int maxn=2e5+5,mod=1e9+7; ll dp[maxn][5]; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int n; cin&gt;&gt;n; string s; cin&gt;&gt;s; s=&quot; &quot;+s; dp[1][0]=1; for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=3;j++) dp[i+1][j]=dp[i][j]; if(s[i]==&#39;a&#39;) { dp[i+1][1]=(dp[i+1][1]+dp[i][0])%mod; } else if(s[i]==&#39;b&#39;) { dp[i+1][2]=(dp[i+1][2]+dp[i][1])%mod; } else if(s[i]==&#39;c&#39;) { dp[i+1][3]=(dp[i+1][3]+dp[i][2])%mod; } else { dp[i+1][0]=dp[i][0]*3%mod; dp[i+1][1]=(dp[i][1]*3%mod+dp[i][0])%mod; dp[i+1][2]=(dp[i][2]*3%mod+dp[i][1])%mod; dp[i+1][3]=(dp[i][3]*3%mod+dp[i][2])%mod; } } cout&lt;&lt;dp[n+1][3]&lt;&lt;endl; return 0; } B - Danger of Mad Snakes题意为给定n条已知x和y坐标的蛇，并给出它们的攻击力。要求你放置m个捕蛇点（只能以给定蛇为圆心），杀伤力半径范围为r。要求计算每一种方案杀死的蛇的杀伤力总和的平方和。 先单独考虑两条蛇i和j的情况。设两条蛇杀伤力为ai和aj，对答案的贡献可以表示为(…+ai+aj+…)2，化简形式为(ai2+aj2)*w1+(2*ai*aj)*w2。 定义以下三种情况： W：导致i,j同时被杀的捕蛇点的数量 U：导致i被杀但j没被杀的捕蛇点的数量 V：导致j被杀但i没被杀的捕蛇点的数量 一个捕蛇点同时包含i和j的组合数可以计算为c[n][m]-c[n-W][m]。 捕蛇点i和j的方案数为（总方案数-i未被选中的方案数-j未被选中的方案数+ij均未被选中的方案数）：c[n-W][m]-c[n-W-U][m]-c[n-W-V][m]+c[n-W-U-V][m]。 两种情况的和即为2*ai*aj的出现次数。 代码如下： #include&lt;bits/stdc++.h&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;math.h&gt; #include &lt;bitset&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} const int maxn=2005,mod=1e9+7; int n,m,r; ll c[maxn][maxn],a[maxn],num[maxn]; int x[maxn],y[maxn]; bitset&lt;maxn&gt; b[maxn]; void init() { for(int i=0;i&lt;=n;i++) { c[i][0]=c[i][i]=1; for(int j=1;j&lt;i;j++) { c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; } } } int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); cin&gt;&gt;n&gt;&gt;m&gt;&gt;r; init(); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(max(abs(x[i]-x[j]),abs(y[i]-y[j]))&lt;=r) b[i][j]=1; } } ll ans=0,w; for(int i=1;i&lt;=n;i++) { w=b[i].count(); num[i]=(c[n][m]-c[n-w][m]+mod)%mod; ans=(ans+num[i]*a[i]%mod*a[i]%mod)%mod; } for(int i=1;i&lt;=n;i++) { for(int j=i+1;j&lt;=n;j++) { w=(b[i]|b[j]).count(); w=(num[i]+num[j]-c[n][m]+c[n-w][m]+mod)%mod; ans=(ans+w*a[i]%mod*a[j]%mod*2%mod)%mod; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } C - Battle Lemmings给你一个长度为 n 的 01序列，每一次操作你可以交换相邻的两个元素。请计算当最多执行 i 次交换操作，数值均为0且中间夹着至少一个1的最大对数。 设1的个数有gs个，答案x可以表示为： n*(n-1)/2 &emsp;&emsp;&emsp; 所有对数 - gs*(gs-1)/2 &emsp;&emsp; (1,1)的对数 - gs*(n-gs) &emsp;&emsp;&emsp; (1,0)的对数 - ∑li*(li-1)/2 &emsp;&emsp;&emsp;(0,0)且直接没有1的对数 其中li为第i段连续0的长度。要使x最大化，则最后一项取最小值。 设f(i,j,k)为分配好原串的前i个1，第i个1放在新串的j位置，且移动步数为k时，最后一项最小是多少。那么有 f(i,j,k)= min{f(i-1,t,k-|posi-j|)+(j-t-1)*((j-t-2)/2)} 其中posi为原串第i个1的位置。 代码如下： #include&lt;bits/stdc++.h&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;math.h&gt; #include &lt;bitset&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int a[105],b[105]; ll dp[85][85][8005]; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int n,gs=0,index=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; gs+=a[i]; if(a[i]) b[++index]=i; } ll ans=n*(n-1)/2-gs*(gs-1)/2-gs*(n-gs),x=0; mem(dp,INF); for(int i=0;i&lt;=index;i++) { if(i) x+=max(0,(b[i]-b[i-1]-1)*(b[i]-b[i-1]-2)/2); dp[i][b[i]][0]=x; } for(int i=1;i&lt;=index;i++) { for(int k=1;k&lt;=n;k++) { for(int j=0;j&lt;k;j++) { for(int l=0;l&lt;=n*(n-1)/2;l++) { dp[i][k][abs(k-b[i])+l]=min(dp[i][k][abs(k-b[i])+l],dp[i-1][j][l]+max(0,(k-j-1)*(k-j-2)/2)); } } } } ll minx=2e18; for(int i=0;i&lt;=n*(n-1)/2;i++) { for(int j=1;j&lt;=n;j++) { minx=min(minx,dp[index][j][i]+max(0,(n-j)*(n-j-1)/2)); } if(index==0) minx=ans; cout&lt;&lt;ans-minx&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; return 0; } D - Subsequences of Length Two给定两个字符串s和t，t的长度固定为2。s中至多可以替换k个字符，求替换后s中子序列与t相同的最大数目。 我们考虑3方的dp。 首先如果t的两个字符相同，则是一个简单的子问题，即求s中有多少个这样的字符，并加上可以更改的最大数目。 如果不相同，我们设dp[i][j][k]表示前i个字符修改了j个后有k个t1。 不修改&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;f[i][j][k] = f[i-1][j][k] 修改为t1 原本就是t1&emsp;&emsp;&emsp;&emsp;&emsp;f[i][j][k] = f[i-1][j][k-1] 否则&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;f[i][j][k] = f[i-1][j-1][k-1] 修改为t2 原本就是t2&emsp;&emsp;&emsp;&emsp;&emsp;f[i][j][k] = f[i-1][j][k] + k 否则&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;f[i][j][k] = f[i-1][j-1][k] + k 初始化的话先全部赋值为无穷小，再将f[0][i][0]赋值为0。 代码如下： #include&lt;bits/stdc++.h&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;math.h&gt; #include &lt;bitset&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b) { return b?gcd(b,a%b):a; } int lcm(int a,int b) { return a/gcd(a,b)*b; } ll powmod(ll a,ll b,ll MOD) { ll ans=1; while(b) { if(b%2) ans=ans*a%MOD; a=a*a%MOD; b/=2; } return ans; } int n,k,f[205][205][205]; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); string s,t; cin&gt;&gt;n&gt;&gt;k; cin&gt;&gt;s&gt;&gt;t; mem(f,-INF); s=&#39; &#39;+s; t=&#39; &#39;+t; if(t[1]==t[2]) { int ans=0; for(int i=1; i&lt;=n; i++) if(s[i]==t[1]) ans++; ans=min(ans+k,n); cout&lt;&lt;ans*(ans-1)/2&lt;&lt;endl; } else { for(int i=0; i&lt;=k; i++) f[0][i][0]=0; for(int i=1; i&lt;=n; i++) for(int j=0; j&lt;=k; j++) for(int l=0; l&lt;=i; l++) { f[i][j][l]=f[i-1][j][l]; if(s[i]==t[1]) f[i][j][l]=max(f[i][j][l],f[i-1][j][l-1]); else if(j) f[i][j][l]=max(f[i][j][l],f[i-1][j-1][l-1]); if(s[i]==t[2]) f[i][j][l]=max(f[i][j][l],f[i-1][j][l]+l); else if(j) f[i][j][l]=max(f[i][j][l],f[i-1][j-1][l]+l); } int ans=0; for(int i=0;i&lt;=n;i++) ans=max(ans,f[n][k][i]); cout&lt;&lt;ans&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"2020 Multi-University Training Contest 5解题报告","slug":"2020-Multi-University-Training-Contest-5解题报告","date":"2020-08-06T02:32:17.000Z","updated":"2020-08-06T02:57:01.154Z","comments":true,"path":"2020/08/06/2020-Multi-University-Training-Contest-5解题报告/","link":"","permalink":"/2020/08/06/2020-Multi-University-Training-Contest-5解题报告/","excerpt":"","text":"2020 Multi-University Training Contest 5解题报告A - Tetrahedron题意给你一个直角四面体，这个直角四面体的三条棱的长度是[1,n]中的随机整数，我们设这个直角四面体的底面上的高为h，求 1/h² 的数学期望是多少。 思路直角四面体有如下关系：1/h²=1/a² + 1/b² + 1/c²。 因为a,b,c都是[1,n]中等概率生成的随机数，所以E(1/h²)=E(3 * 1/a²)=3 * E(1/a²)。 E(1/a²)=(1/1² 1/n + 1/2² 1/n + 1/3² 1/n + …+ 1/n² 1/n) =1/n * (1/1² + 1/2² + 1/3² + …+ 1/n²) 可以对逆元进行线性打表，并计算平方前缀和。 代码#include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; const int maxn=6e6+5,mod=998244353; ll inv[maxn],sum[maxn]; void ni() { inv[0]=inv[1]=1; for(int i=2;i&lt;maxn;i++) { inv[i]=(mod-(mod/i))*inv[mod%i]%mod; } } void gsum() { for(int i=1;i&lt;maxn;i++) { sum[i]=(sum[i-1]+inv[i]*inv[i]%mod)%mod; } } int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); ni(); gsum(); int t; cin&gt;&gt;t; while(t--) { int n; cin&gt;&gt;n; cout&lt;&lt;(3*inv[n]*sum[n])%mod&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"hdu多校","slug":"hdu多校","permalink":"/tags/hdu多校/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"Codeforces 1313C2 - Skyscrapers","slug":"Codeforces-1313C2-Skyscrapers","date":"2020-03-04T04:36:13.000Z","updated":"2020-03-04T05:04:12.030Z","comments":true,"path":"2020/03/04/Codeforces-1313C2-Skyscrapers/","link":"","permalink":"/2020/03/04/Codeforces-1313C2-Skyscrapers/","excerpt":"","text":"很少单独写一道题的题解，但是这题的解题方法是比较惊艳到我的。 此题可以作为leetcode常出题“山脉数组”的延伸。之前貌似也遇到过相似题目，无法得解，现在了却了之前不会的遗憾。 Codeforces 1313C2 - Skyscrapers单调栈是我在lertcode做题过程中经常出现的名词，但在竞赛过程中一直不得见，直到寒假camp讲到此类应用。 这道题的实质是给出一串数组，让你把他变成山脉数组（可以理解为中间有一个最高元素，依次向两旁越来越低，形似山脉）且各元素相加和最大。 o(n^2)比较常规的处理方法就是枚举出这个最高元素，从而按照规则处理，比较出最大值。但是题目中n的范围是50000，因此这个复杂度最高为O(nlogn)。而使用单调栈处理，这个复杂度基本达到o(n)，且不可能被卡常。 为什么我们需要使用单调栈？单调栈可以帮助我们找到一段单调递增/递减的区间，那么在此题中，这段单调递减区间是不是最后都变成了区间内最小值才符合要求？ 我们需要对数组进行正反两遍处理： 数组 l[i] 表示：以楼房 i 为峰值时，其左边（包括自己）所有楼房的总层数。 数组 r[i] 表示：以楼房 i 为峰值时，其右边（包括自己）所有楼房的总层数。 先讨论 l[i] 数组的求法，对于楼房 i 而言，如果m[i]是1~i中的最小值，那么 l[i]=i∗a[i]； 否则，若 j 为 i 前面，满足：a[j] &lt; a[i]且(i−j)最小，那么 l[i]=l[j]+a[i]∗(i−j)。 r[i] 的求法同理。 那么维护这段区间只需要用上单调栈就迎刃而解了。 代码如下： #include&lt;bits/stdc++.h&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;math.h&gt; #include &lt;bitset&gt; #include &lt;algorithm&gt; #include &lt;climits&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} ll a[500005],l[500005],r[500005]; stack&lt;ll&gt;s; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) { while(!s.empty()&amp;&amp;a[s.top()]&gt;a[i]) s.pop(); if(s.empty()) l[i]=1ll*i*a[i]; else l[i]=l[s.top()]+1ll*(i-s.top())*a[i]; s.push(i); } while(!s.empty()) s.pop(); for(int i=n;i&gt;0;i--) { while(!s.empty()&amp;&amp;a[s.top()]&gt;a[i]) s.pop(); if(s.empty()) r[i]=1ll*(n-i+1)*a[i]; else r[i]=r[s.top()]+1ll*(s.top()-i)*a[i]; s.push(i); } ll ans=0; int p; for(int i=1;i&lt;=n;i++) { if(l[i]+r[i]-a[i]&gt;ans) { ans=l[i]+r[i]-a[i]; p=i; } } for(int i=p-1;i&gt;0;i--) { if(a[i]&gt;a[i+1]) a[i]=a[i+1]; } for(int i=p+1;i&lt;=n;i++) { if(a[i]&gt;a[i-1]) a[i]=a[i-1]; } for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; return 0; } 那么对于这个算法的复杂度怎么计算？栈的复杂度看似不可测，实际上对于1~n中每个元素在整个for循环中都只会出入栈一次。那么整个程序就只涉及到常数倍的O(n)，对于n=50000来说，时间复杂度是非常低的。题目的时限是3s，实际上这个程序只用了不到500ms。","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"思维","slug":"思维","permalink":"/tags/思维/"},{"name":"单调栈","slug":"单调栈","permalink":"/tags/单调栈/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"[转载]c++计算几何算法大全","slug":"转载-c-计算几何算法大全","date":"2020-02-12T09:18:05.000Z","updated":"2020-02-12T09:22:01.285Z","comments":true,"path":"2020/02/12/转载-c-计算几何算法大全/","link":"","permalink":"/2020/02/12/转载-c-计算几何算法大全/","excerpt":"","text":"/* 计算几何 目录 ㈠ 点的基本运算 1. 平面上两点之间距离 1 2. 判断两点是否重合 1 3. 矢量叉乘 1 4. 矢量点乘 2 5. 判断点是否在线段上 2 6. 求一点饶某点旋转后的坐标 2 7. 求矢量夹角 2 ㈡ 线段及直线的基本运算 1. 点与线段的关系 3 2. 求点到线段所在直线垂线的垂足 4 3. 点到线段的最近点 4 4. 点到线段所在直线的距离 4 5. 点到折线集的最近距离 4 6. 判断圆是否在多边形内 5 7. 求矢量夹角余弦 5 8. 求线段之间的夹角 5 9. 判断线段是否相交 6 10.判断线段是否相交但不交在端点处 6 11.求线段所在直线的方程 6 12.求直线的斜率 7 13.求直线的倾斜角 7 14.求点关于某直线的对称点 7 15.判断两条直线是否相交及求直线交点 7 16.判断线段是否相交，如果相交返回交点 7 ㈢ 多边形常用算法模块 1. 判断多边形是否简单多边形 8 2. 检查多边形顶点的凸凹性 9 3. 判断多边形是否凸多边形 9 4. 求多边形面积 9 5. 判断多边形顶点的排列方向，方法一 10 6. 判断多边形顶点的排列方向，方法二 10 7. 射线法判断点是否在多边形内 10 8. 判断点是否在凸多边形内 11 9. 寻找点集的graham算法 12 10.寻找点集凸包的卷包裹法 13 11.判断线段是否在多边形内 14 12.求简单多边形的重心 15 13.求凸多边形的重心 17 14.求肯定在给定多边形内的一个点 17 15.求从多边形外一点出发到该多边形的切线 18 16.判断多边形的核是否存在 19 ㈣ 圆的基本运算 1 .点是否在圆内 20 2 .求不共线的三点所确定的圆 21 ㈤ 矩形的基本运算 1.已知矩形三点坐标，求第4点坐标 22 ㈥ 常用算法的描述 22 ㈦ 补充 1．两圆关系： 24 2．判断圆是否在矩形内： 24 3．点到平面的距离： 25 4．点是否在直线同侧： 25 5．镜面反射线： 25 6．矩形包含： 26 7．两圆交点： 27 8．两圆公共面积： 28 9. 圆和直线关系： 29 10. 内切圆： 30 11. 求切点： 31 12. 线段的左右旋： 31 13．公式： 32 */ /* 需要包含的头文件 */ #include &lt;cmath &gt; /* 常用的常量定义 */ const double INF = 1E200 const double EP = 1E-10 const int MAXV = 300 const double PI = 3.14159265 /* 基本几何结构 */ struct POINT { double x; double y; POINT(double a=0, double b=0) { x=a; y=b;} //constructor }; struct LINESEG { POINT s; POINT e; LINESEG(POINT a, POINT b) { s=a; e=b;} LINESEG() { } }; struct LINE // 直线的解析方程 a*x+b*y+c=0 为统一表示，约定 a &gt;= 0 { double a; double b; double c; LINE(double d1=1, double d2=-1, double d3=0) {a=d1; b=d2; c=d3;} }; /********************** * * * 点的基本运算 * * * **********************/ double dist(POINT p1,POINT p2) // 返回两点之间欧氏距离 { return( sqrt( (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y) ) ); } bool equal_point(POINT p1,POINT p2) // 判断两个点是否重合 { return ( (abs(p1.x-p2.x)&lt;EP)&amp;&amp;(abs(p1.y-p2.y)&lt;EP) ); } /****************************************************************************** r=multiply(sp,ep,op),得到(sp-op)和(ep-op)的叉积 r&gt;0：ep在矢量opsp的逆时针方向； r=0：opspep三点共线； r&lt;0：ep在矢量opsp的顺时针方向 *******************************************************************************/ double multiply(POINT sp,POINT ep,POINT op) { return((sp.x-op.x)*(ep.y-op.y)-(ep.x-op.x)*(sp.y-op.y)); } /* r=dotmultiply(p1,p2,op),得到矢量(p1-op)和(p2-op)的点积，如果两个矢量都非零矢量 r&lt;0：两矢量夹角为锐角； r=0：两矢量夹角为直角； r&gt;0：两矢量夹角为钝角 *******************************************************************************/ double dotmultiply(POINT p1,POINT p2,POINT p0) { return ((p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y)); } /****************************************************************************** 判断点p是否在线段l上 条件：(p在线段l所在的直线上) &amp;&amp; (点p在以线段l为对角线的矩形内) *******************************************************************************/ bool online(LINESEG l,POINT p) { return( (multiply(l.e,p,l.s)==0) &amp;&amp;( ( (p.x-l.s.x)*(p.x-l.e.x)&lt;=0 )&amp;&amp;( (p.y-l.s.y)*(p.y-l.e.y)&lt;=0 ) ) ); } // 返回点p以点o为圆心逆时针旋转alpha(单位：弧度)后所在的位置 POINT rotate(POINT o,double alpha,POINT p) { POINT tp; p.x-=o.x; p.y-=o.y; tp.x=p.x*cos(alpha)-p.y*sin(alpha)+o.x; tp.y=p.y*cos(alpha)+p.x*sin(alpha)+o.y; return tp; } /* 返回顶角在o点，起始边为os，终止边为oe的夹角(单位：弧度) 角度小于pi，返回正值 角度大于pi，返回负值 可以用于求线段之间的夹角 原理： r = dotmultiply(s,e,o) / (dist(o,s)*dist(o,e)) r&#39;= multiply(s,e,o) r &gt;= 1 angle = 0; r &lt;= -1 angle = -PI -1&lt;r&lt;1 &amp;&amp; r&#39;&gt;0 angle = arccos(r) -1&lt;r&lt;1 &amp;&amp; r&#39;&lt;=0 angle = -arccos(r) */ double angle(POINT o,POINT s,POINT e) { double cosfi,fi,norm; double dsx = s.x - o.x; double dsy = s.y - o.y; double dex = e.x - o.x; double dey = e.y - o.y; cosfi=dsx*dex+dsy*dey; norm=(dsx*dsx+dsy*dsy)*(dex*dex+dey*dey); cosfi /= sqrt( norm ); if (cosfi &gt;= 1.0 ) return 0; if (cosfi &lt;= -1.0 ) return -3.1415926; fi=acos(cosfi); if (dsx*dey-dsy*dex&gt;0) return fi; // 说明矢量os 在矢量 oe的顺时针方向 return -fi; } /*****************************\\ * * * 线段及直线的基本运算 * * * \\*****************************/ /* 判断点与线段的关系,用途很广泛 本函数是根据下面的公式写的，P是点C到线段AB所在直线的垂足 AC dot AB r = --------- ||AB||^2 (Cx-Ax)(Bx-Ax) + (Cy-Ay)(By-Ay) = ------------------------------- L^2 r has the following meaning: r=0 P = A r=1 P = B r&lt;0 P is on the backward extension of AB r&gt;1 P is on the forward extension of AB 0&lt;r&lt;1 P is interior to AB */ double relation(POINT p,LINESEG l) { LINESEG tl; tl.s=l.s; tl.e=p; return dotmultiply(tl.e,l.e,l.s)/(dist(l.s,l.e)*dist(l.s,l.e)); } // 求点C到线段AB所在直线的垂足 P POINT perpendicular(POINT p,LINESEG l) { double r=relation(p,l); POINT tp; tp.x=l.s.x+r*(l.e.x-l.s.x); tp.y=l.s.y+r*(l.e.y-l.s.y); return tp; } /* 求点p到线段l的最短距离,并返回线段上距该点最近的点np 注意：np是线段l上到点p最近的点，不一定是垂足 */ double ptolinesegdist(POINT p,LINESEG l,POINT &amp;np) { double r=relation(p,l); if(r&lt;0) { np=l.s; return dist(p,l.s); } if(r&gt;1) { np=l.e; return dist(p,l.e); } np=perpendicular(p,l); return dist(p,np); } // 求点p到线段l所在直线的距离,请注意本函数与上个函数的区别 double ptoldist(POINT p,LINESEG l) { return abs(multiply(p,l.e,l.s))/dist(l.s,l.e); } /* 计算点到折线集的最近距离,并返回最近点. 注意：调用的是ptolineseg()函数 */ double ptopointset(int vcount,POINT pointset[],POINT p,POINT &amp;q) { int i; double cd=double(INF),td; LINESEG l; POINT tq,cq; for(i=0;i&lt;vcount-1;i++) { l.s=pointset[i]; l.e=pointset[i+1]; td=ptolinesegdist(p,l,tq); if(td&lt;cd) { cd=td; cq=tq; } } q=cq; return cd; } /* 判断圆是否在多边形内.ptolineseg()函数的应用2 */ bool CircleInsidePolygon(int vcount,POINT center,double radius,POINT polygon[]) { POINT q; double d; q.x=0; q.y=0; d=ptopointset(vcount,polygon,center,q); if(d&lt;radius||fabs(d-radius)&lt;EP) return true; else return false; } /* 返回两个矢量l1和l2的夹角的余弦(-1 --- 1)注意：如果想从余弦求夹角的话，注意反余弦函数的定义域是从 0到pi */ double cosine(LINESEG l1,LINESEG l2) { return (((l1.e.x-l1.s.x)*(l2.e.x-l2.s.x) + (l1.e.y-l1.s.y)*(l2.e.y-l2.s.y))/(dist(l1.e,l1.s)*dist(l2.e,l2.s))) ); } // 返回线段l1与l2之间的夹角 单位：弧度 范围(-pi，pi) double lsangle(LINESEG l1,LINESEG l2) { POINT o,s,e; o.x=o.y=0; s.x=l1.e.x-l1.s.x; s.y=l1.e.y-l1.s.y; e.x=l2.e.x-l2.s.x; e.y=l2.e.y-l2.s.y; return angle(o,s,e); } // 如果线段u和v相交(包括相交在端点处)时，返回true // //判断P1P2跨立Q1Q2的依据是：( P1 - Q1 ) × ( Q2 - Q1 ) * ( Q2 - Q1 ) × ( P2 - Q1 ) &gt;= 0。 //判断Q1Q2跨立P1P2的依据是：( Q1 - P1 ) × ( P2 - P1 ) * ( P2 - P1 ) × ( Q2 - P1 ) &gt;= 0。 bool intersect(LINESEG u,LINESEG v) { return( (max(u.s.x,u.e.x)&gt;=min(v.s.x,v.e.x))&amp;&amp; //排斥实验 (max(v.s.x,v.e.x)&gt;=min(u.s.x,u.e.x))&amp;&amp; (max(u.s.y,u.e.y)&gt;=min(v.s.y,v.e.y))&amp;&amp; (max(v.s.y,v.e.y)&gt;=min(u.s.y,u.e.y))&amp;&amp; (multiply(v.s,u.e,u.s)*multiply(u.e,v.e,u.s)&gt;=0)&amp;&amp; //跨立实验 (multiply(u.s,v.e,v.s)*multiply(v.e,u.e,v.s)&gt;=0)); } // (线段u和v相交)&amp;&amp;(交点不是双方的端点) 时返回true bool intersect_A(LINESEG u,LINESEG v) { return ((intersect(u,v))&amp;&amp; (!online(u,v.s))&amp;&amp; (!online(u,v.e))&amp;&amp; (!online(v,u.e))&amp;&amp; (!online(v,u.s))); } // 线段v所在直线与线段u相交时返回true；方法：判断线段u是否跨立线段v bool intersect_l(LINESEG u,LINESEG v) { return multiply(u.s,v.e,v.s)*multiply(v.e,u.e,v.s)&gt;=0; } // 根据已知两点坐标，求过这两点的直线解析方程： a*x+b*y+c = 0 (a &gt;= 0) LINE makeline(POINT p1,POINT p2) { LINE tl; int sign = 1; tl.a=p2.y-p1.y; if(tl.a&lt;0) { sign = -1; tl.a=sign*tl.a; } tl.b=sign*(p1.x-p2.x); tl.c=sign*(p1.y*p2.x-p1.x*p2.y); return tl; } // 根据直线解析方程返回直线的斜率k,水平线返回 0,竖直线返回 1e200 double slope(LINE l) { if(abs(l.a) &lt; 1e-20) return 0; if(abs(l.b) &lt; 1e-20) return INF; return -(l.a/l.b); } // 返回直线的倾斜角alpha ( 0 - pi) double alpha(LINE l) { if(abs(l.a)&lt; EP) return 0; if(abs(l.b)&lt; EP) return PI/2; double k=slope(l); if(k&gt;0) return atan(k); else return PI+atan(k); } // 求点p关于直线l的对称点 POINT symmetry(LINE l,POINT p) { POINT tp; tp.x=((l.b*l.b-l.a*l.a)*p.x-2*l.a*l.b*p.y-2*l.a*l.c)/(l.a*l.a+l.b*l.b); tp.y=((l.a*l.a-l.b*l.b)*p.y-2*l.a*l.b*p.x-2*l.b*l.c)/(l.a*l.a+l.b*l.b); return tp; } // 如果两条直线 l1(a1*x+b1*y+c1 = 0), l2(a2*x+b2*y+c2 = 0)相交，返回true，且返回交点p bool lineintersect(LINE l1,LINE l2,POINT &amp;p) // 是 L1，L2 { double d=l1.a*l2.b-l2.a*l1.b; if(abs(d)&lt;EP) // 不相交 return false; p.x = (l2.c*l1.b-l1.c*l2.b)/d; p.y = (l2.a*l1.c-l1.a*l2.c)/d; return true; } // 如果线段l1和l2相交，返回true且交点由(inter)返回，否则返回false bool intersection(LINESEG l1,LINESEG l2,POINT &amp;inter) { LINE ll1,ll2; ll1=makeline(l1.s,l1.e); ll2=makeline(l2.s,l2.e); if(lineintersect(ll1,ll2,inter)) return online(l1,inter); else return false; } /******************************\\ * * * 多边形常用算法模块 * * * \\******************************/ // 如果无特别说明，输入多边形顶点要求按逆时针排列 /* 返回值：输入的多边形是简单多边形，返回true 要 求：输入顶点序列按逆时针排序 说 明：简单多边形定义： 1：循环排序中相邻线段对的交是他们之间共有的单个点 2：不相邻的线段不相交 本程序默认第一个条件已经满足 */ bool issimple(int vcount,POINT polygon[]) { int i,cn; LINESEG l1,l2; for(i=0;i&lt;vcount;i++) { l1.s=polygon[i]; l1.e=polygon[(i+1)%vcount]; cn=vcount-3; while(cn) { l2.s=polygon[(i+2)%vcount]; l2.e=polygon[(i+3)%vcount]; if(intersect(l1,l2)) break; cn--; } if(cn) return false; } return true; } // 返回值：按输入顺序返回多边形顶点的凸凹性判断，bc[i]=1,iff:第i个顶点是凸顶点 void checkconvex(int vcount,POINT polygon[],bool bc[]) { int i,index=0; POINT tp=polygon[0]; for(i=1;i&lt;vcount;i++) // 寻找第一个凸顶点 { if(polygon[i].y&lt;tp.y||(polygon[i].y == tp.y&amp;&amp;polygon[i].x&lt;tp.x)) { tp=polygon[i]; index=i; } } int count=vcount-1; bc[index]=1; while(count) // 判断凸凹性 { if(multiply(polygon[(index+1)%vcount],polygon[(index+2)%vcount],polygon[index])&gt;=0 ) bc[(index+1)%vcount]=1; else bc[(index+1)%vcount]=0; index++; count--; } } // 返回值：多边形polygon是凸多边形时，返回true bool isconvex(int vcount,POINT polygon[]) { bool bc[MAXV]; checkconvex(vcount,polygon,bc); for(int i=0;i&lt;vcount;i++) // 逐一检查顶点，是否全部是凸顶点 if(!bc[i]) return false; return true; } // 返回多边形面积(signed)；输入顶点按逆时针排列时，返回正值；否则返回负值 double area_of_polygon(int vcount,POINT polygon[]) { int i; double s; if (vcount&lt;3) return 0; s=polygon[0].y*(polygon[vcount-1].x-polygon[1].x); for (i=1;i&lt;vcount;i++) s+=polygon[i].y*(polygon[(i-1)].x-polygon[(i+1)%vcount].x); return s/2; } // 如果输入顶点按逆时针排列，返回true bool isconterclock(int vcount,POINT polygon[]) { return area_of_polygon(vcount,polygon)&gt;0; } // 另一种判断多边形顶点排列方向的方法 bool isccwize(int vcount,POINT polygon[]) { int i,index; POINT a,b,v; v=polygon[0]; index=0; for(i=1;i&lt;vcount;i++) // 找到最低且最左顶点，肯定是凸顶点 { if(polygon[i].y&lt;v.y||polygon[i].y == v.y &amp;&amp; polygon[i].x&lt;v.x) { index=i; } } a=polygon[(index-1+vcount)%vcount]; // 顶点v的前一顶点 b=polygon[(index+1)%vcount]; // 顶点v的后一顶点 return multiply(v,b,a)&gt;0; } /******************************************************************************************** 射线法判断点q与多边形polygon的位置关系，要求polygon为简单多边形，顶点逆时针排列 如果点在多边形内： 返回0 如果点在多边形边上： 返回1 如果点在多边形外： 返回2 *********************************************************************************************/ int insidepolygon(int vcount,POINT Polygon[],POINT q) { int c=0,i,n; LINESEG l1,l2; bool bintersect_a,bonline1,bonline2,bonline3; double r1,r2; l1.s=q; l1.e=q; l1.e.x=double(INF); n=vcount; for (i=0;i&lt;vcount;i++) { l2.s=Polygon[i]; l2.e=Polygon[(i+1)%n]; if(online(l2,q)) return 1; // 如果点在边上，返回1 if ( (bintersect_a=intersect_A(l1,l2))|| // 相交且不在端点 ( (bonline1=online(l1,Polygon[(i+1)%n]))&amp;&amp; // 第二个端点在射线上 ( (!(bonline2=online(l1,Polygon[(i+2)%n])))&amp;&amp; /* 前一个端点和后一个端点在射线两侧 */ ((r1=multiply(Polygon[i],Polygon[(i+1)%n],l1.s)*multiply(Polygon[(i+1)%n],Polygon[(i+2)%n],l1.s))&gt;0) || (bonline3=online(l1,Polygon[(i+2)%n]))&amp;&amp; /* 下一条边是水平线，前一个端点和后一个端点在射线两侧 */ ((r2=multiply(Polygon[i],Polygon[(i+2)%n],l1.s)*multiply(Polygon[(i+2)%n], Polygon[(i+3)%n],l1.s))&gt;0) ) ) ) c++; } if(c%2 == 1) return 0; else return 2; } //点q是凸多边形polygon内时，返回true；注意：多边形polygon一定要是凸多边形 bool InsideConvexPolygon(int vcount,POINT polygon[],POINT q) // 可用于三角形！ { POINT p; LINESEG l; int i; p.x=0;p.y=0; for(i=0;i&lt;vcount;i++) // 寻找一个肯定在多边形polygon内的点p：多边形顶点平均值 { p.x+=polygon[i].x; p.y+=polygon[i].y; } p.x /= vcount; p.y /= vcount; for(i=0;i&lt;vcount;i++) { l.s=polygon[i];l.e=polygon[(i+1)%vcount]; if(multiply(p,l.e,l.s)*multiply(q,l.e,l.s)&lt;0) /* 点p和点q在边l的两侧，说明点q肯定在多边形外 */ break; } return (i==vcount); } /********************************************** 寻找凸包的graham 扫描法 PointSet为输入的点集； ch为输出的凸包上的点集，按照逆时针方向排列; n为PointSet中的点的数目 len为输出的凸包上的点的个数 **********************************************/ void Graham_scan(POINT PointSet[],POINT ch[],int n,int &amp;len) { int i,j,k=0,top=2; POINT tmp; // 选取PointSet中y坐标最小的点PointSet[k]，如果这样的点有多个，则取最左边的一个 for(i=1;i&lt;n;i++) if ( PointSet[i].y&lt;PointSet[k].y || (PointSet[i].y==PointSet[k].y) &amp;&amp; (PointSet[i].x&lt;PointSet[k].x) ) k=i; tmp=PointSet[0]; PointSet[0]=PointSet[k]; PointSet[k]=tmp; // 现在PointSet中y坐标最小的点在PointSet[0] for (i=1;i&lt;n-1;i++) /* 对顶点按照相对PointSet[0]的极角从小到大进行排序，极角相同的按照距离PointSet[0]从近到远进行排序 */ { k=i; for (j=i+1;j&lt;n;j++) if ( multiply(PointSet[j],PointSet[k],PointSet[0])&gt;0 || // 极角更小 (multiply(PointSet[j],PointSet[k],PointSet[0])==0) &amp;&amp; /* 极角相等，距离更短 */ dist(PointSet[0],PointSet[j])&lt;dist(PointSet[0],PointSet[k]) ) k=j; tmp=PointSet[i]; PointSet[i]=PointSet[k]; PointSet[k]=tmp; } ch[0]=PointSet[0]; ch[1]=PointSet[1]; ch[2]=PointSet[2]; for (i=3;i&lt;n;i++) { while (multiply(PointSet[i],ch[top],ch[top-1])&gt;=0) top--; ch[++top]=PointSet[i]; } len=top+1; } // 卷包裹法求点集凸壳，参数说明同graham算法 void ConvexClosure(POINT PointSet[],POINT ch[],int n,int &amp;len) { int top=0,i,index,first; double curmax,curcos,curdis; POINT tmp; LINESEG l1,l2; bool use[MAXV]; tmp=PointSet[0]; index=0; // 选取y最小点，如果多于一个，则选取最左点 for(i=1;i&lt;n;i++) { if(PointSet[i].y&lt;tmp.y||PointSet[i].y == tmp.y&amp;&amp;PointSet[i].x&lt;tmp.x) { index=i; } use[i]=false; } tmp=PointSet[index]; first=index; use[index]=true; index=-1; ch[top++]=tmp; tmp.x-=100; l1.s=tmp; l1.e=ch[0]; l2.s=ch[0]; while(index!=first) { curmax=-100; curdis=0; // 选取与最后一条确定边夹角最小的点，即余弦值最大者 for(i=0;i&lt;n;i++) { if(use[i])continue; l2.e=PointSet[i]; curcos=cosine(l1,l2); // 根据cos值求夹角余弦，范围在 （-1 -- 1 ） if(curcos&gt;curmax || fabs(curcos-curmax)&lt;1e-6 &amp;&amp; dist(l2.s,l2.e)&gt;curdis) { curmax=curcos; index=i; curdis=dist(l2.s,l2.e); } } use[first]=false; //清空第first个顶点标志，使最后能形成封闭的hull use[index]=true; ch[top++]=PointSet[index]; l1.s=ch[top-2]; l1.e=ch[top-1]; l2.s=ch[top-1]; } len=top-1; } /********************************************************************************************* 判断线段是否在简单多边形内(注意：如果多边形是凸多边形，下面的算法可以化简) 必要条件一：线段的两个端点都在多边形内； 必要条件二：线段和多边形的所有边都不内交； 用途： 1. 判断折线是否在简单多边形内 2. 判断简单多边形是否在另一个简单多边形内 **********************************************************************************************/ bool LinesegInsidePolygon(int vcount,POINT polygon[],LINESEG l) { // 判断线端l的端点是否不都在多边形内 if(!insidepolygon(vcount,polygon,l.s)||!insidepolygon(vcount,polygon,l.e)) return false; int top=0,i,j; POINT PointSet[MAXV],tmp; LINESEG s; for(i=0;i&lt;vcount;i++) { s.s=polygon[i]; s.e=polygon[(i+1)%vcount]; if(online(s,l.s)) //线段l的起始端点在线段s上 PointSet[top++]=l.s; else if(online(s,l.e)) //线段l的终止端点在线段s上 PointSet[top++]=l.e; else { if(online(l,s.s)) //线段s的起始端点在线段l上 PointSet[top++]=s.s; else if(online(l,s.e)) // 线段s的终止端点在线段l上 PointSet[top++]=s.e; else { if(intersect(l,s)) // 这个时候如果相交，肯定是内交，返回false return false; } } } for(i=0;i&lt;top-1;i++) /* 冒泡排序，x坐标小的排在前面；x坐标相同者，y坐标小的排在前面 */ { for(j=i+1;j&lt;top;j++) { if( PointSet[i].x&gt;PointSet[j].x || fabs(PointSet[i].x-PointSet[j].x)&lt;EP &amp;&amp; PointSet[i].y&gt;PointSet[j].y ) { tmp=PointSet[i]; PointSet[i]=PointSet[j]; PointSet[j]=tmp; } } } for(i=0;i&lt;top-1;i++) { tmp.x=(PointSet[i].x+PointSet[i+1].x)/2; //得到两个相邻交点的中点 tmp.y=(PointSet[i].y+PointSet[i+1].y)/2; if(!insidepolygon(vcount,polygon,tmp)) return false; } return true; } /********************************************************************************************* 求任意简单多边形polygon的重心 需要调用下面几个函数： void AddPosPart(); 增加右边区域的面积 void AddNegPart(); 增加左边区域的面积 void AddRegion(); 增加区域面积 在使用该程序时，如果把xtr,ytr,wtr,xtl,ytl,wtl设成全局变量就可以使这些函数的形式得到化简, 但要注意函数的声明和调用要做相应变化 **********************************************************************************************/ void AddPosPart(double x, double y, double w, double &amp;xtr, double &amp;ytr, double &amp;wtr) { if (abs(wtr + w)&lt;1e-10 ) return; // detect zero regions xtr = ( wtr*xtr + w*x ) / ( wtr + w ); ytr = ( wtr*ytr + w*y ) / ( wtr + w ); wtr = w + wtr; return; } void AddNegPart(double x, ouble y, double w, double &amp;xtl, double &amp;ytl, double &amp;wtl) { if ( abs(wtl + w)&lt;1e-10 ) return; // detect zero regions xtl = ( wtl*xtl + w*x ) / ( wtl + w ); ytl = ( wtl*ytl + w*y ) / ( wtl + w ); wtl = w + wtl; return; } void AddRegion ( double x1, double y1, double x2, double y2, double &amp;xtr, double &amp;ytr, double &amp;wtr, double &amp;xtl, double &amp;ytl, double &amp;wtl ) { if ( abs (x1 - x2)&lt; 1e-10 ) return; if ( x2 &gt; x1 ) { AddPosPart ((x2+x1)/2, y1/2, (x2-x1) * y1,xtr,ytr,wtr); /* rectangle 全局变量变化处 */ AddPosPart ((x1+x2+x2)/3, (y1+y1+y2)/3, (x2-x1)*(y2-y1)/2,xtr,ytr,wtr); // triangle 全局变量变化处 } else { AddNegPart ((x2+x1)/2, y1/2, (x2-x1) * y1,xtl,ytl,wtl); // rectangle 全局变量变化处 AddNegPart ((x1+x2+x2)/3, (y1+y1+y2)/3, (x2-x1)*(y2-y1)/2,xtl,ytl,wtl); // triangle 全局变量变化处 } } POINT cg_simple(int vcount,POINT polygon[]) { double xtr,ytr,wtr,xtl,ytl,wtl; //注意： 如果把xtr,ytr,wtr,xtl,ytl,wtl改成全局变量后这里要删去 POINT p1,p2,tp; xtr = ytr = wtr = 0.0; xtl = ytl = wtl = 0.0; for(int i=0;i&lt;vcount;i++) { p1=polygon[i]; p2=polygon[(i+1)%vcount]; AddRegion(p1.x,p1.y,p2.x,p2.y,xtr,ytr,wtr,xtl,ytl,wtl); //全局变量变化处 } tp.x = (wtr*xtr + wtl*xtl) / (wtr + wtl); tp.y = (wtr*ytr + wtl*ytl) / (wtr + wtl); return tp; } // 求凸多边形的重心,要求输入多边形按逆时针排序 POINT gravitycenter(int vcount,POINT polygon[]) { POINT tp; double x,y,s,x0,y0,cs,k; x=0;y=0;s=0; for(int i=1;i&lt;vcount-1;i++) { x0=(polygon[0].x+polygon[i].x+polygon[i+1].x)/3; y0=(polygon[0].y+polygon[i].y+polygon[i+1].y)/3; //求当前三角形的重心 cs=multiply(polygon[i],polygon[i+1],polygon[0])/2; //三角形面积可以直接利用该公式求解 if(abs(s)&lt;1e-20) { x=x0;y=y0;s+=cs;continue; } k=cs/s; //求面积比例 x=(x+k*x0)/(1+k); y=(y+k*y0)/(1+k); s += cs; } tp.x=x; tp.y=y; return tp; } /************************************************ 给定一简单多边形，找出一个肯定在该多边形内的点 定理1 ：每个多边形至少有一个凸顶点 定理2 ：顶点数&gt;=4的简单多边形至少有一条对角线 结论 ： x坐标最大，最小的点肯定是凸顶点 y坐标最大，最小的点肯定是凸顶点 ************************************************/ POINT a_point_insidepoly(int vcount,POINT polygon[]) { POINT v,a,b,r; int i,index; v=polygon[0]; index=0; for(i=1;i&lt;vcount;i++) //寻找一个凸顶点 { if(polygon[i].y&lt;v.y) { v=polygon[i]; index=i; } } a=polygon[(index-1+vcount)%vcount]; //得到v的前一个顶点 b=polygon[(index+1)%vcount]; //得到v的后一个顶点 POINT tri[3],q; tri[0]=a;tri[1]=v;tri[2]=b; double md=INF; int in1=index; bool bin=false; for(i=0;i&lt;vcount;i++) //寻找在三角形avb内且离顶点v最近的顶点q { if(i == index)continue; if(i == (index-1+vcount)%vcount)continue; if(i == (index+1)%vcount)continue; if(!InsideConvexPolygon(3,tri,polygon[i]))continue; bin=true; if(dist(v,polygon[i])&lt;md) { q=polygon[i]; md=dist(v,q); } } if(!bin) //没有顶点在三角形avb内，返回线段ab中点 { r.x=(a.x+b.x)/2; r.y=(a.y+b.y)/2; return r; } r.x=(v.x+q.x)/2; //返回线段vq的中点 r.y=(v.y+q.y)/2; return r; } /*********************************************************************************************** 求从多边形外一点p出发到一个简单多边形的切线,如果存在返回切点,其中rp点是右切点,lp是左切点 注意：p点一定要在多边形外 ,输入顶点序列是逆时针排列 原 理： 如果点在多边形内肯定无切线;凸多边形有唯一的两个切点,凹多边形就可能有多于两个的切点; 如果polygon是凸多边形，切点只有两个只要找到就可以,可以化简此算法 如果是凹多边形还有一种算法可以求解:先求凹多边形的凸包,然后求凸包的切线 /***********************************************************************************************/ void pointtangentpoly(int vcount,POINT polygon[],POINT p,POINT &amp;rp,POINT &amp;lp) { LINESEG ep,en; bool blp,bln; rp=polygon[0]; lp=polygon[0]; for(int i=1;i&lt;vcount;i++) { ep.s=polygon[(i+vcount-1)%vcount]; ep.e=polygon[i]; en.s=polygon[i]; en.e=polygon[(i+1)%vcount]; blp=multiply(ep.e,p,ep.s)&gt;=0; // p is to the left of pre edge bln=multiply(en.e,p,en.s)&gt;=0; // p is to the left of next edge if(!blp&amp;&amp;bln) { if(multiply(polygon[i],rp,p)&gt;0) // polygon[i] is above rp rp=polygon[i]; } if(blp&amp;&amp;!bln) { if(multiply(lp,polygon[i],p)&gt;0) // polygon[i] is below lp lp=polygon[i]; } } return ; } // 如果多边形polygon的核存在，返回true，返回核上的一点p.顶点按逆时针方向输入 bool core_exist(int vcount,POINT polygon[],POINT &amp;p) { int i,j,k; LINESEG l; LINE lineset[MAXV]; for(i=0;i&lt;vcount;i++) { lineset[i]=makeline(polygon[i],polygon[(i+1)%vcount]); } for(i=0;i&lt;vcount;i++) { for(j=0;j&lt;vcount;j++) { if(i == j)continue; if(lineintersect(lineset[i],lineset[j],p)) { for(k=0;k&lt;vcount;k++) { l.s=polygon[k]; l.e=polygon[(k+1)%vcount]; if(multiply(p,l.e,l.s)&gt;0) //多边形顶点按逆时针方向排列，核肯定在每条边的左侧或边上 break; } if(k == vcount) //找到了一个核上的点 break; } } if(j&lt;vcount) break; } if(i&lt;vcount) return true; else return false; } /*************************\\ * * * 圆的基本运算 * * * \\*************************/ /****************************************************************************** 返回值 ： 点p在圆内(包括边界)时，返回true 用途 ： 因为圆为凸集，所以判断点集，折线，多边形是否在圆内时， 只需要逐一判断点是否在圆内即可。 *******************************************************************************/ bool point_in_circle(POINT o,double r,POINT p) { double d2=(p.x-o.x)*(p.x-o.x)+(p.y-o.y)*(p.y-o.y); double r2=r*r; return d2&lt;r2||abs(d2-r2)&lt;EP; } /****************************************************************************** 用 途 ：求不共线的三点确定一个圆 输 入 ：三个点p1,p2,p3 返回值 ：如果三点共线，返回false；反之，返回true。圆心由q返回，半径由r返回 *******************************************************************************/ bool cocircle(POINT p1,POINT p2,POINT p3,POINT &amp;q,double &amp;r) { double x12=p2.x-p1.x; double y12=p2.y-p1.y; double x13=p3.x-p1.x; double y13=p3.y-p1.y; double z2=x12*(p1.x+p2.x)+y12*(p1.y+p2.y); double z3=x13*(p1.x+p3.x)+y13*(p1.y+p3.y); double d=2.0*(x12*(p3.y-p2.y)-y12*(p3.x-p2.x)); if(abs(d)&lt;EP) //共线，圆不存在 return false; q.x=(y13*z2-y12*z3)/d; q.y=(x12*z3-x13*z2)/d; r=dist(p1,q); return true; } int line_circle(LINE l,POINT o,double r,POINT &amp;p1,POINT &amp;p2) { return true; } /**************************\\ * * * 矩形的基本运算 * * * \\**************************/ /* 说明：因为矩形的特殊性，常用算法可以化简： 1.判断矩形是否包含点 只要判断该点的横坐标和纵坐标是否夹在矩形的左右边和上下边之间。 2.判断线段、折线、多边形是否在矩形中 因为矩形是个凸集，所以只要判断所有端点是否都在矩形中就可以了。 3.判断圆是否在矩形中 圆在矩形中的充要条件是：圆心在矩形中且圆的半径小于等于圆心到矩形四边的距离的最小值。 */ // 已知矩形的三个顶点(a,b,c)，计算第四个顶点d的坐标. 注意：已知的三个顶点可以是无序的 POINT rect4th(POINT a,POINT b,POINT c) { POINT d; if(abs(dotmultiply(a,b,c))&lt;EP) // 说明c点是直角拐角处 { d.x=a.x+b.x-c.x; d.y=a.y+b.y-c.y; } if(abs(dotmultiply(a,c,b))&lt;EP) // 说明b点是直角拐角处 { d.x=a.x+c.x-b.x; d.y=a.y+c.y-b.x; } if(abs(dotmultiply(c,b,a))&lt;EP) // 说明a点是直角拐角处 { d.x=c.x+b.x-a.x; d.y=c.y+b.y-a.y; } return d; } /*************************\\ * * * 常用算法的描述 * * * \\*************************/ /* 尚未实现的算法： 1. 求包含点集的最小圆 2. 求多边形的交 3. 简单多边形的三角剖分 4. 寻找包含点集的最小矩形 5. 折线的化简 6. 判断矩形是否在矩形中 7. 判断矩形能否放在矩形中 8. 矩形并的面积与周长 9. 矩形并的轮廓 10.矩形并的闭包 11.矩形的交 12.点集中的最近点对 13.多边形的并 14.圆的交与并 15.直线与圆的关系 16.线段与圆的关系 17.求多边形的核监视摄象机 18.求点集中不相交点对 railwai *//* 寻找包含点集的最小矩形 原理：该矩形至少一条边与点集的凸壳的某条边共线 First take the convex hull of the points. Let the resulting convex polygon be P. It has been known for some time that the minimum area rectangle enclosing P must have one rectangle side flush with (i.e., collinear with and overlapping) one edge of P. This geometric fact was used by Godfried Toussaint to develop the &quot;rotating calipers&quot; algorithm in a hard-to-find 1983 paper, &quot;Solving Geometric Problems with the Rotating Calipers&quot; (Proc. IEEE MELECON). The algorithm rotates a surrounding rectangle from one flush edge to the next, keeping track of the minimum area for each edge. It achieves O(n) time (after hull computation). See the &quot;Rotating Calipers Homepage&quot; http://www.cs.mcgill.ca/~orm/rotcal.frame.html for a description and applet. *//* 折线的化简 伪码如下： Input: tol = the approximation tolerance L = {V0,V1,...,Vn-1} is any n-vertex polyline Set start = 0; Set k = 0; Set W0 = V0; for each vertex Vi (i=1,n-1) { if Vi is within tol from Vstart then ignore it, and continue with the next vertex Vi is further than tol away from Vstart so add it as a new vertex of the reduced polyline Increment k++; Set Wk = Vi; Set start = i; as the new initial vertex } Output: W = {W0,W1,...,Wk-1} = the k-vertex simplified polyline */ /********************\\ * * * 补充 * * * \\********************/ //两圆关系： /* 两圆： 相离： return 1； 外切： return 2； 相交： return 3； 内切： return 4； 内含： return 5； */ int CircleRelation(POINT p1, double r1, POINT p2, double r2) { double d = sqrt( (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y) ); if( fabs(d-r1-r2) &lt; EP ) // 必须保证前两个if先被判定！ return 2; if( fabs(d-fabs(r1-r2)) &lt; EP ) return 4; if( d &gt; r1+r2 ) return 1; if( d &lt; fabs(r1-r2) ) return 5; if( fabs(r1-r2) &lt; d &amp;&amp; d &lt; r1+r2 ) return 3; return 0; // indicate an error! } //判断圆是否在矩形内： // 判定圆是否在矩形内，是就返回true（设矩形水平，且其四个顶点由左上开始按顺时针排列） // 调用ptoldist函数，在第4页 bool CircleRecRelation(POINT pc, double r, POINT pr1, POINT pr2, POINT pr3, POINT pr4) { if( pr1.x &lt; pc.x &amp;&amp; pc.x &lt; pr2.x &amp;&amp; pr3.y &lt; pc.y &amp;&amp; pc.y &lt; pr2.y ) { LINESEG line1(pr1, pr2); LINESEG line2(pr2, pr3); LINESEG line3(pr3, pr4); LINESEG line4(pr4, pr1); if( r&lt;ptoldist(pc,line1) &amp;&amp; r&lt;ptoldist(pc,line2) &amp;&amp; r&lt;ptoldist(pc,line3) &amp;&amp; r&lt;ptoldist(pc,line4) ) return true; } return false; } //点到平面的距离： //点到平面的距离,平面用一般式表示ax+by+cz+d=0 double P2planeDist(double x, double y, double z, double a, double b, double c, double d) { return fabs(a*x+b*y+c*z+d) / sqrt(a*a+b*b+c*c); } //点是否在直线同侧： //两个点是否在直线同侧，是则返回true bool SameSide(POINT p1, POINT p2, LINE line) { return (line.a * p1.x + line.b * p1.y + line.c) * (line.a * p2.x + line.b * p2.y + line.c) &gt; 0; } //镜面反射线： // 已知入射线、镜面，求反射线。 // a1,b1,c1为镜面直线方程(a1 x + b1 y + c1 = 0 ,下同)系数; //a2,b2,c2为入射光直线方程系数; //a,b,c为反射光直线方程系数. // 光是有方向的，使用时注意：入射光向量:&lt;-b2,a2&gt;；反射光向量:&lt;b,-a&gt;. // 不要忘记结果中可能会有&quot;negative zeros&quot; void reflect(double a1,double b1,double c1,double a2,double b2,double c2,double &amp;a,double &amp;b,double &amp;c) { double n,m; double tpb,tpa; tpb=b1*b2+a1*a2; tpa=a2*b1-a1*b2; m=(tpb*b1+tpa*a1)/(b1*b1+a1*a1); n=(tpa*b1-tpb*a1)/(b1*b1+a1*a1); if(fabs(a1*b2-a2*b1)&lt;1e-20) { a=a2;b=b2;c=c2; return; } double xx,yy; //(xx,yy)是入射线与镜面的交点。 xx=(b1*c2-b2*c1)/(a1*b2-a2*b1); yy=(a2*c1-a1*c2)/(a1*b2-a2*b1); a=n; b=-m; c=m*yy-xx*n; } //矩形包含： // 矩形2（C，D）是否在1（A，B）内 bool r2inr1(double A,double B,double C,double D) { double X,Y,L,K,DMax; if (A &lt; B) { double tmp = A; A = B; B = tmp; } if (C &lt; D) { double tmp = C; C = D; D = tmp; } if (A &gt; C &amp;&amp; B &gt; D) // trivial case return true; else if (D &gt;= B) return false; else { X = sqrt(A * A + B * B); // outer rectangle&#39;s diagonal Y = sqrt(C * C + D * D); // inner rectangle&#39;s diagonal if (Y &lt; B) // check for marginal conditions return true; // the inner rectangle can freely rotate inside else if (Y &gt; X) return false; else { L = (B - sqrt(Y * Y - A * A)) / 2; K = (A - sqrt(Y * Y - B * B)) / 2; DMax = sqrt(L * L + K * K); if (D &gt;= DMax) return false; else return true; } } } //两圆交点： // 两圆已经相交（相切） void c2point(POINT p1,double r1,POINT p2,double r2,POINT &amp;rp1,POINT &amp;rp2) { double a,b,r; a=p2.x-p1.x; b=p2.y-p1.y; r=(a*a+b*b+r1*r1-r2*r2)/2; if(a==0&amp;&amp;b!=0) { rp1.y=rp2.y=r/b; rp1.x=sqrt(r1*r1-rp1.y*rp1.y); rp2.x=-rp1.x; } else if(a!=0&amp;&amp;b==0) { rp1.x=rp2.x=r/a; rp1.y=sqrt(r1*r1-rp1.x*rp2.x); rp2.y=-rp1.y; } else if(a!=0&amp;&amp;b!=0) { double delta; delta=b*b*r*r-(a*a+b*b)*(r*r-r1*r1*a*a); rp1.y=(b*r+sqrt(delta))/(a*a+b*b); rp2.y=(b*r-sqrt(delta))/(a*a+b*b); rp1.x=(r-b*rp1.y)/a; rp2.x=(r-b*rp2.y)/a; } rp1.x+=p1.x; rp1.y+=p1.y; rp2.x+=p1.x; rp2.y+=p1.y; } //两圆公共面积： // 必须保证相交 double c2area(POINT p1,double r1,POINT p2,double r2) { POINT rp1,rp2; c2point(p1,r1,p2,r2,rp1,rp2); if(r1&gt;r2) //保证r2&gt;r1 { swap(p1,p2); swap(r1,r2); } double a,b,rr; a=p1.x-p2.x; b=p1.y-p2.y; rr=sqrt(a*a+b*b); double dx1,dy1,dx2,dy2; double sita1,sita2; dx1=rp1.x-p1.x; dy1=rp1.y-p1.y; dx2=rp2.x-p1.x; dy2=rp2.y-p1.y; sita1=acos((dx1*dx2+dy1*dy2)/r1/r1); dx1=rp1.x-p2.x; dy1=rp1.y-p2.y; dx2=rp2.x-p2.x; dy2=rp2.y-p2.y; sita2=acos((dx1*dx2+dy1*dy2)/r2/r2); double s=0; if(rr&lt;r2)//相交弧为优弧 s=r1*r1*(PI-sita1/2+sin(sita1)/2)+r2*r2*(sita2-sin(sita2))/2; else//相交弧为劣弧 s=(r1*r1*(sita1-sin(sita1))+r2*r2*(sita2-sin(sita2)))/2; return s; } //圆和直线关系： //0----相离 1----相切 2----相交 int clpoint(POINT p,double r,double a,double b,double c,POINT &amp;rp1,POINT &amp;rp2) { int res=0; c=c+a*p.x+b*p.y; double tmp; if(a==0&amp;&amp;b!=0) { tmp=-c/b; if(r*r&lt;tmp*tmp) res=0; else if(r*r==tmp*tmp) { res=1; rp1.y=tmp; rp1.x=0; } else { res=2; rp1.y=rp2.y=tmp; rp1.x=sqrt(r*r-tmp*tmp); rp2.x=-rp1.x; } } else if(a!=0&amp;&amp;b==0) { tmp=-c/a; if(r*r&lt;tmp*tmp) res=0; else if(r*r==tmp*tmp) { res=1; rp1.x=tmp; rp1.y=0; } else { res=2; rp1.x=rp2.x=tmp; rp1.y=sqrt(r*r-tmp*tmp); rp2.y=-rp1.y; } } else if(a!=0&amp;&amp;b!=0) { double delta; delta=b*b*c*c-(a*a+b*b)*(c*c-a*a*r*r); if(delta&lt;0) res=0; else if(delta==0) { res=1; rp1.y=-b*c/(a*a+b*b); rp1.x=(-c-b*rp1.y)/a; } else { res=2; rp1.y=(-b*c+sqrt(delta))/(a*a+b*b); rp2.y=(-b*c-sqrt(delta))/(a*a+b*b); rp1.x=(-c-b*rp1.y)/a; rp2.x=(-c-b*rp2.y)/a; } } rp1.x+=p.x; rp1.y+=p.y; rp2.x+=p.x; rp2.y+=p.y; return res; } //内切圆： void incircle(POINT p1,POINT p2,POINT p3,POINT &amp;rp,double &amp;r) { double dx31,dy31,dx21,dy21,d31,d21,a1,b1,c1; dx31=p3.x-p1.x; dy31=p3.y-p1.y; dx21=p2.x-p1.x; dy21=p2.y-p1.y; d31=sqrt(dx31*dx31+dy31*dy31); d21=sqrt(dx21*dx21+dy21*dy21); a1=dx31*d21-dx21*d31; b1=dy31*d21-dy21*d31; c1=a1*p1.x+b1*p1.y; double dx32,dy32,dx12,dy12,d32,d12,a2,b2,c2; dx32=p3.x-p2.x; dy32=p3.y-p2.y; dx12=-dx21; dy12=-dy21; d32=sqrt(dx32*dx32+dy32*dy32); d12=d21; a2=dx12*d32-dx32*d12; b2=dy12*d32-dy32*d12; c2=a2*p2.x+b2*p2.y; rp.x=(c1*b2-c2*b1)/(a1*b2-a2*b1); rp.y=(c2*a1-c1*a2)/(a1*b2-a2*b1); r=fabs(dy21*rp.x-dx21*rp.y+dx21*p1.y-dy21*p1.x)/d21; } //求切点： // p---圆心坐标， r---圆半径， sp---圆外一点， rp1,rp2---切点坐标 void cutpoint(POINT p,double r,POINT sp,POINT &amp;rp1,POINT &amp;rp2) { POINT p2; p2.x=(p.x+sp.x)/2; p2.y=(p.y+sp.y)/2; double dx2,dy2,r2; dx2=p2.x-p.x; dy2=p2.y-p.y; r2=sqrt(dx2*dx2+dy2*dy2); c2point(p,r,p2,r2,rp1,rp2); } //线段的左右旋： /* l2在l1的左/右方向（l1为基准线） 返回 0 ： 重合； 返回 1 ： 右旋； 返回 –1 ： 左旋； */ int rotat(LINESEG l1,LINESEG l2) { double dx1,dx2,dy1,dy2; dx1=l1.s.x-l1.e.x; dy1=l1.s.y-l1.e.y; dx2=l2.s.x-l2.e.x; dy2=l2.s.y-l2.e.y; double d; d=dx1*dy2-dx2*dy1; if(d==0) return 0; else if(d&gt;0) return -1; else return 1; } /* 公式： 球坐标公式： 直角坐标为 P(x, y, z) 时，对应的球坐标是(rsinφcosθ, rsinφsinθ, rcosφ),其中φ是向量OP与Z轴的夹角，范围[0，π]；是OP在XOY面上的投影到X轴的旋角，范围[0，2π] 直线的一般方程转化成向量方程： ax+by+c=0 x-x0 y-y0 ------ = ------- // (x0,y0)为直线上一点，m,n为向量 m n 转换关系： a=n；b=-m；c=m·y0-n·x0； m=-b; n=a; 三点平面方程： 三点为P1，P2，P3 设向量 M1=P2-P1; M2=P3-P1; 平面法向量： M=M1 x M2 （） 平面方程： M.i(x-P1.x)+M.j(y-P1.y)+M.k(z-P1.z)=0 */","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"模板","slug":"模板","permalink":"/tags/模板/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"昭奚旧草","slug":"昭奚旧草","date":"2020-02-12T07:20:23.000Z","updated":"2020-02-12T08:17:45.926Z","comments":true,"path":"2020/02/12/昭奚旧草/","link":"","permalink":"/2020/02/12/昭奚旧草/","excerpt":"","text":"初时读这书，只觉得字字晦涩，兼之怪力乱神，读了几页便索性弃了。 后来才知，这是一个爱得多么深沉的故事呀~ 女主是奚山君，亦唤作奚山。因她之名，她统治的山叫奚山。三百年前，她还不是个妖精的时候，有个人世间的名字，叫乔植。是她那芝兰玉树的哥哥乔荷取的，希望植成这棵乔木可参天。 男主是公子扶苏，这是奚山君婚书上的名字：乔公女，三百岁。太平日，嫁扶苏。他仍是人间太子时，叫做成婴，是不受皇帝宠爱的长子，是已故皇后留下的唯一孩子。再往前久一些，三百年前，他叫乔荷，有一个三寸丁的侏儒妹乔植。 那便从三百年前的事，乔植与乔荷的故事开始吧。乔植和乔荷是同父异母的兄妹。乔植是乔太尉与原配妫氏所生，乔太尉后来又娶了华国长公主，也就是太祖唯一的女儿。乔荷是华国长公主唯一的儿子，也是太祖唯一的外孙。 华国长公主善妒，视乔植为眼中钉肉中刺。乔植自幼被哥哥乔荷养大。乔荷唯恐她过早绽放光芒，被害去性命，给她喝下了抑制生长的药。于是，就有了三寸丁的侏儒妹，被外人视作乔家的耻辱。 乔荷七岁那年，天子设局预谋在公主寿宴除去马陵，不料阴差阳错却反让乔荷中毒，虽保住了性命，却染上了寒毒。 太祖无子，皇位人选在外孙乔荷与宗室之子敏言之间举棋不定。世人都道，乔荷阴毒，不及敏言大度。太祖的心也更偏向于敏言，只因他是成家的孩子，乔荷终究姓乔，是外人。 乔荷无争夺皇位之心，他只想把最爱的这个妹妹，嫁给世界上最好的儿郎。奚山君是乔荷赠予乔植的雅号，盼她不受束缚，自由自在，不需要自己争取荣华功名。他想把妹妹嫁给敏言，然后辅佐敏言，成为乔植一辈子的依靠。乔荷为乔植画像，画中是他想象中她未来的貌美，却被乔植误会哥哥讥讽她。画像交由乔植表姐妫氏保管。 乔荷求天子为乔植与敏言赐婚。众人只当他是为羞辱敏言。敏言夜探太尉府，想瞧清未来妻子的模样。不料误入妫氏闺房，对画像上的女子一见钟情，以为妫氏。自此敏言开始抗拒与乔植的婚事，一心想求娶妫氏。 乔荷出征，预备归来便送妹妹出嫁，送她嫁给这世上最好的儿郎。便有人等她长大，有人带她去看海底的白珠、悬崖上的红花，欢喜她欢喜到打仗吃酒读书抚琴都忍不住带在身边，山高水长地过一辈子。因为乔植喜欢表姐妫氏，他也预备回来与妫氏成亲。出征之前，他停掉了给乔植的药。 乔荷征战极为顺利，不料乔荷部下谢季伙同敏言，设计诬陷乔荷叛国。天子震怒，立敏言为太子，赐婚妫氏和敏言，下诏押罪臣乔荷回都，乔荷在回都途中寒疾复发，死在路上。 谢季又受华国长公主指示，换掉了乔荷留给乔植的遗言，致使乔植生了求死之心。乔植为乔荷痛哭三十日，三十日后她嫁给敏言为妾。大婚当日，她自尽于鹦鹉桥上，死在了敏言怀里。敏言才知自己认错了人，立乔植为元后，自此意难平。 乔太尉算出女儿重生之法，是嫁与转世的乔荷，而转世的乔荷是皇室后人，于是向天子讨诏，又将乔植挖出，华国公主使人划花了乔植的脸，又割了她的舌头。葬于悬棺之内。 乔荷死后，来到道祖处，说他来世要与哭他三十日的人做夫妻三年（也就是乔植，之后的奚山），爱拜祭他的乞婆三年并给她一世荣华（也就是章咸之）。 乔植死后，自此改名奚山。奚山君身为望岁木所化，面容枯槁，是眼圈青黑的痨病鬼形象。 奚山到道祖处，想要满足乔荷的心愿，于是把自己的美貌和荣华富贵都给了乞婆（章咸之）。 道祖说乔荷想要天下，奚山后来便处心积虑的为他谋取天下。但其实，乔荷从来不想要天下，只想要妹妹好好的。 这是故事的开篇，所有的开始。","categories":[{"name":"书评","slug":"书评","permalink":"/categories/书评/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"书评","slug":"书评","permalink":"/categories/书评/"}]},{"title":"code jam to i/O for Women 2019题解","slug":"code-jam-to-i-O-for-Women-2019题解","date":"2020-01-31T03:59:17.000Z","updated":"2020-02-12T03:12:29.310Z","comments":true,"path":"2020/01/31/code-jam-to-i-O-for-Women-2019题解/","link":"","permalink":"/2020/01/31/code-jam-to-i-O-for-Women-2019题解/","excerpt":"谷歌承诺 “building for everyone”。 Code Jam to I/O for Women 是谷歌提供的一个平台和机会，让全球顶尖的程序媛们华山论剑！ Code Jam to I/O for Women 是一个单轮的在线算法挑战！全球排名前 150 名的参与者，就有机会获得一张年度 Google I/O 大会的门票（包差旅）哦！！","text":"谷歌承诺 “building for everyone”。 Code Jam to I/O for Women 是谷歌提供的一个平台和机会，让全球顶尖的程序媛们华山论剑！ Code Jam to I/O for Women 是一个单轮的在线算法挑战！全球排名前 150 名的参与者，就有机会获得一张年度 Google I/O 大会的门票（包差旅）哦！！ code jam to i/O for Women 2019题解Grid EscapeProblemYou are designing a new “escape” adventure that uses a rectangular grid of rooms (unit cells) with R rows and C columns. Each room has four doors oriented in the four orthogonal directions of the grid: north, south, east, and west. The doors on the border of the grid lead outside, and all of the other doors lead to other rooms. The adventure will be played by exactly R × C players, with each player starting in a different one of the R × C rooms. Once everyone is in position and the game starts, all of the doors close, and there is a mechanical trick: one of the four doors in each room can be opened from inside the room, and the other three doors cannot be opened. This remains consistent throughout the adventure; in a given room, it is always the same door that can be opened. Notice that it is possible that a door that connects two rooms might be able to be opened from one side but not the other. Each player moves independently of all other players. Players can only go through doors that they opened themselves, and they must close doors behind them. Each player will keep going through doors until they go through a door that leads outside (and therefore they escape), or they have made R × C moves without escaping (at which point they are considered to have failed, and they do not escape). You want to choose which door in each room can be opened, such that exactly K of the players will be able to escape. Can you find a way to do this, or determine that it is IMPOSSIBLE? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each consists of one line containing three integers R, C, and K, as described above. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is IMPOSSIBLE if there is no solution, or POSSIBLE if there is. If there is a solution, output R more lines of C characters each, representing the grid of rooms. The j-th character on the i-th of these lines represents the room in the i-th row and j-th column of the grid; each character must be either uppercase N, S, E, or W, according to whether the door that opens from that room is the one that leads north, south, east, or west. If multiple answers are possible, you may output any one of them. Limits1 ≤ T ≤ 100. Time limit:20 seconds per test set. (10 seconds per test run.) Memory limit:1GB. 1 ≤ R. 1 ≤ C. 0 ≤ K ≤ R × C. Test set 1 (Visible) 1 ≤ (R × C) ≤ 8. Test set 2 (Hidden) 1 ≤ (R × C) ≤ 100. SampleInput 2 2 3 2 1 1 0 Output Case #1: POSSIBLE SES SNW Case #2: IMPOSSIBLE In our solution for Sample Case #1, the two players who start in the westernmost two rooms will go south until they escape, whereas the four players who start in the other four rooms will travel between those rooms in an endless clockwise circle and cannot escape. In Sample Case #2, there is only one room, so the player can definitely escape regardless of which particular door can be opened. 解题思路这是一道构造题。每个人构造方式必然不尽相同，分享一下我的思路吧。 首先我们需要明确什么时候直接输出IMPOSSIBLE。一开始我以为只有1 1 0才满足这个条件。但是后来在写构造的过程中我发现只要满足条件C*W-k==1的，都是不能够构造出来的。 采用反证法，假设C*W-k==1可以构造，即所有格子只有一个格子不能逃脱。那这个格子不管开哪扇门，必然都可以进入可逃脱区，与已知不能逃脱相悖。因此C*W-k==1是不能被构造的。 那么我们可以从后往前对格子进行可逃脱赋值。最后一排格子标记为’E’,剩余只需要标记为’S’，即可从右下角离开。完成这部分标记后，需对剩余格子进行一遍搜索配对。 如果我们选取两个相邻格子，让他们可以开启同一扇门（即相邻边），则这两个格子都无法逃脱，陷入死循环。因此剩余偶数个格子时随意搜索应该都可以配对成功。 如果剩余奇数格子时，则只需要将最后三个格子配对，也可以形成死循环。 代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} char a[105][105]; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int t; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { int r,c,k; cin&gt;&gt;r&gt;&gt;c&gt;&gt;k; if(r*c-k==1) cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: IMPOSSIBLE&quot;&lt;&lt;endl; else { int x=r*c; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: POSSIBLE&quot;&lt;&lt;endl; for(int j=1;j&lt;=r;j++) { for(int m=1;m&lt;=c;m++) { a[j][m]=&#39; &#39;; } } for(int j=0;j&lt;k;j++) { if((x-1)/c==r-1) { a[r][x%c==0?c:x%c]=&#39;E&#39;; } else { a[(x-1)/c+1][x%c==0?c:x%c]=&#39;S&#39;; } x--; } for(int j=1;j&lt;=r;j++) { for(int m=1;m&lt;=c;m++) { if(a[j][m]==&#39; &#39;) { if(a[j+1][m]==&#39; &#39;) { a[j][m]=&#39;S&#39;; a[j+1][m]=&#39;N&#39;; } else if(a[j][m+1]==&#39; &#39;) { a[j][m]=&#39;E&#39;; a[j][m+1]=&#39;W&#39;; } else { if(j&gt;1) a[j][m]=&#39;N&#39;; else if(m&gt;1) a[j][m]=&#39;W&#39;; } } } } for(int j=1;j&lt;=r;j++) { for(int m=1;m&lt;=c;m++) { cout&lt;&lt;a[j][m]; } cout&lt;&lt;endl; } } } return 0; } Parcel PostsProblemYou just bought a parcel of land that is K kilometers long; it is so narrow that, for the purposes of this problem, we will consider it to be a polyline that runs from west to east, varying in elevation. You know the elevations of the land (in meters) at K + 1 regularly spaced measurement marks M0, M1, …, MK. These marks are 0, 1, …, K km, respectively, from the western end. In this region, a wooden post denotes the boundary between two adjacent parcels of land. Wooden posts can only be placed at measurement marks, and there can be at most one post at each mark. Right now, there are two posts: one at the 0 km mark, and one at the K km mark. A measurement mark with a post is considered to be part of both of the parcels it demarcates, so your parcel of land includes all measurement marks between 0 and K km, inclusive. A parcel is considered desirable if it contains three measurement marks such that the west-most and east-most of those three marks are both strictly higher than the remaining one of the three marks, or both strictly lower than the remaining one of the three marks. People like some variation in their landscapes! Notice that these three marks are not necessarily consecutive, and the west-most and east-most of the three marks are not necessarily the west-most and east-most marks of the parcel. Consider an example with K = 5 and M0, M1, …, MK = 5, 6, 6, 1, 2, 4. The measurement marks with elevations 5, 2, and 4 satisfy the condition, as do the measurement marks with elevations 6, 1, and 2. However, the measurement marks with elevations 6, 6, and 1 do not satisfy the condition, nor do the measurement marks with elevations 1, 2, and 4. Any three measurement marks that satisfy the condition make the whole parcel desirable; for example, a parcel containing the measurement marks 4 7 6 7 is desirable because of the first three values. Your parcel is desirable, but you think it may be possible to extract even more value from it! You want to add additional posts to this parcel to divide it up into multiple parcels, all of which must be desirable, since you do not want to waste any land. What is the largest number of posts you can add? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each case begins with one line containing an integer K: the length, in kilometers, of your parcel of land. Then, there is one more line with K + 1 integers M0, M1, …, Mk; where Mi is the elevation (in meters) at the measurement mark that is i km from the western end of your land. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the largest possible number of posts you can add, as described above. LimitsTime limit:20 seconds per test set. (10 seconds per test run.) Memory limit:1GB. 1 ≤ T ≤ 100. 0 ≤ Mi ≤ 1000, for all i. (Mi - Mj) × (Mk - Mj) &gt; 0, for some i &lt; j &lt; k. (Your starting parcel is desirable.) Test set 1 (Visible) 4 ≤ K ≤ 10. Test set 2 (Hidden) 4 ≤ K ≤ 1000. SampleInput 4 4 4 8 7 3 5 4 4 8 7 7 5 7 1 2 2 1 2 1 2 1 6 2 1 3 10 9 12 20 Output Case #1: 1 Case #2: 0 Case #3: 2 Case #4: 1 In Sample Case #1, you can add one post at 2 km to get a total of two desirable parcels. The parcel from 0 to 2 km is desirable because 4 &lt; 8 and 8 &gt; 7. The parcel from 2 to 4 km is desirable because 7 &gt; 3 and 3 &lt; 5. In Sample Case #2, there is no way to add another post. If you added one at 1 km or 3 km, one of the parcels would include only two measurement marks and could not be desirable. If you added one at 2 km, the parcel between 0 and 2 km would be desirable, but the parcel between 2 and 4 km would not. In Sample Case #3, posts can be added at 3 km and 5 km. In Sample Case #4, a post can be added at 2 km. Notice that the parcel from 2 km to 6 km is desirable because 10 &gt; 9 and 9 &lt; 12. However, there is no way to add a second post. 解题思路我真的没想到……就是个暴力（努力想了半天发现数据小，而且！给了20s！！！绝了。这大概也是跟codeforces最大的不同吧，无法想象codeforces给20s是一种怎样的体验。） 首先我们要明确题意（这题目真的非常绕），实质是问你最多能将数组w划定多少个区间，使得每个区间内存在i&lt;j&lt;k，且w[i]&lt;w[j],w[k]&lt;w[j],或者w[i]&gt;w[j],w[k]&gt;w[j]。 那么我们可以通过枚举区间的右端点，极端暴力是O(n^3)，二分优化可以做到O(n^2logn)。但是题目时限非常宽，所以就直接暴力了。 #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep(x,a,b) for(int x=a;x&lt;b;x++) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int m[1005]; int main() { ios::sync_with_stdio(false),cin.tie(0),cout.tie(0); int t; cin&gt;&gt;t; for(int temp=1;temp&lt;=t;temp++) { int k; cin&gt;&gt;k; for(int i=0;i&lt;=k;i++) cin&gt;&gt;m[i]; int ans=0,i,j; for(i=0;i&lt;=k;i=j) { for(j=i+2;j&lt;=k;j++) { int flag=0; for(int x=i+1;x&lt;j;x++) { if((m[x]&gt;m[i]&amp;&amp;m[x]&gt;m[j])||(m[x]&lt;m[i]&amp;&amp;m[x]&lt;m[j])) { ans++; flag=1; break; } } if(flag) break; } } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;temp&lt;&lt;&quot;: &quot;&lt;&lt;ans-1&lt;&lt;endl; } return 0; } SheepwalkingProblemBleatrix Trotter is a sheep who lives in a two-dimensional field that is an infinite grid of unit cells. Her home is in a unit cell that we denote as (0, 0) — that is, all coordinates are given relative to Bleatrix’s home cell. However, because she has been sleepwalking, she is currently in the unit cell at the coordinates (X, Y) — that is, in a cell X columns east of, and Y rows north of, her home cell. The two sheepdogs who have been assigned to protect Bleatrix have just noticed that she is missing, and now they want to herd her back to her home cell. Before each of Bleatrix’s moves, the two sheepdogs can move to any grid cells that they want, except that they cannot both move to the same cell, and neither one can move to Bleatrix’s current cell. Once the sheepdogs are in place, Bleatrix, who is sleepwalking, will make a random unit move in a direction that would not take her into a cell with a sheepdog. That is, she takes the set of four possible unit moves (north, south, west, east), discards any that would move her into a cell with a sheepdog, and then chooses uniformly at random from the remaining moves. Then the sheepdogs can position themselves again, and so on (notice that, unlike Bleatrix, the sheepdogs do not have to make unit moves). Once Bleatrix arrives at her home at (0, 0), she stops sleepwalking, wakes up, and grazes peacefully, and does not make any more moves thereafter. If the sheepdogs coordinate their movements to minimize the expected number of Bleatrix’s moves to reach her home, what is that expected number? InputThe first line of the input gives the number of test cases, T. T test cases follow. Each case consists of one line with two integers X and Y, representing the coordinates of Bleatrix’s starting cell, as described above. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the expected number of Bleatrix’s moves, as described above. y will be considered correct if it is within an absolute or relative error of 10-6 of the correct answer. See the Competing section of the FAQ for an explanation of what that means, and what formats of real numbers we accept. LimitsTime limit:20 seconds per test set. (10 seconds per test run.) Memory limit:1GB. (X, Y) ≠ (0, 0). Test set 1 (Visible) 1 ≤ T ≤ 48. -3 ≤ X ≤ 3. -3 ≤ Y ≤ 3. Test set 2 (Hidden) 1 ≤ T ≤ 100. -500 ≤ X ≤ 500. -500 ≤ Y ≤ 500. SampleInput 1 -1 1 Output Case #1: 4.000000 Notice that the values of X and/or Y may be negative. An X value of -1, for example, means that the cell is one unit west of Bleatrix’s home cell. (Similarly, a negative value of Y means the cell is south of Bleatrix’s home cell.) In the sample case, Bleatrix starts off one cell to the north of, and one cell to the west of, her home. Before she makes her first move, the two sheepdogs could position themselves in cells (-2, 1) and (-1, 2). Then, whichever direction she might choose, she would end up only one step away from her home… but the sheepdogs could not guarantee that she would go there on her next move! The remaining details are left for you to discover.","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"博弈论初探","slug":"博弈论初探","date":"2020-01-27T06:17:36.000Z","updated":"2022-01-09T07:10:44.987Z","comments":true,"path":"2020/01/27/博弈论初探/","link":"","permalink":"/2020/01/27/博弈论初探/","excerpt":"我们把动物利用大自然移动的瘾魂， 在决策人期待的空间里， 形成三维均衡的学术理论， 称为博弈论。 社会学领域非常经典的博弈论问题就是囚徒困境， 在算法竞赛领域的博弈论往往归纳为ICG（公平组合游戏），典型表现为取石子游戏。","text":"我们把动物利用大自然移动的瘾魂， 在决策人期待的空间里， 形成三维均衡的学术理论， 称为博弈论。 社会学领域非常经典的博弈论问题就是囚徒困境， 在算法竞赛领域的博弈论往往归纳为ICG（公平组合游戏），典型表现为取石子游戏。 博弈论初探博弈论入门之巴什博弈 有n个物品放置一堆，两个人轮流从中取物， 规定每次至少取1个，最多取m个，最后取光者得胜。 我们从最简单的情景开始分析 当石子有1~m个时，毫无疑问，先手必胜 当石子有m+1个时，先手无论拿几个，后手都可以拿干净，先手必败 当石子有m+2~2m时，先手可以拿走几个，剩下m+1个，先手必胜 我们不难发现，面临m+1个石子的人一定失败。 这样的话两个人的最优策略一定是通过拿走石子，使得对方拿石子时还有m+1个 设当前的石子数为n=k∗(m+1)+r 先手会首先拿走r个，接下来假设后手拿走x个，先手会拿走m+1−x个，这样博弈下去后手最终一定失败 设当前的石子数为n=k∗(m+1) 假设先手拿x个，后手一定会拿m+1−x个，这样下去先手一定失败 例题 hdu1846 巴什博弈裸题 #include&lt;cstdio&gt; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n%(m+1) !=0) printf(&quot;first\\n&quot;); else printf(&quot;second\\n&quot;); } return 0; } hdu4764 唐和江是好朋友。为了决定晚餐谁请客，他们在玩游戏。具体来说，唐和江将轮流在白板上写数字(整数)。唐先写，然后写江，再写唐，等等……此外，假设前一轮中所写的数字是X，下一个玩游戏的人应该写一个数字Y，使1 &lt;= Y - X &lt;= k。第一个写数字不小于N的人将输掉游戏。注意，在第一轮中，Tang只能在[1,k]范围内(包括1和k)写下一个数字。你可以认为唐和江的表现将一直处于最佳状态，因为他们都是非常聪明的学生。 我们可以把模型抽象一下,有n−1个石子，一个人最多拿k个，问最后谁赢 ——》裸的巴什博奕 #include&lt;cstdio&gt; int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m)) { if((n-1)%(m+1) !=0) printf(&quot;Tang\\n&quot;); else printf(&quot;Jiang\\n&quot;); } return 0; } hdu1847 巴什博弈的一个小变形。第一个必胜态不难推理出来是3。那么再仔细想，其实只需要用到1和2，等同于k值为2的巴什博弈。 #include&lt;cstdio&gt; int main() { int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) { if(n%3!=0) printf(&quot;Kiki\\n&quot;); else printf(&quot;Cici\\n&quot;); } return 0; } 博弈论入门之斐波那契博弈 有一堆石子，两个顶尖聪明的人玩游戏，先取者可以取走任意多个，但不能全取完，以后每人取的石子数不能超过上个人的两倍 斐波那契博弈有一个非常重要的性质： 先手必败，当且仅当石子数为斐波那契数 是不是很神奇？？ 证明如下： n=2 先手输 n=3 先手输 假设n&lt;=k，且牌数为Fibonacci数时，都是先手必输。 那么n=k+1时，因为F(k+1)=F(k)+F(k−1)，即要取完F(k+1)张牌，可以分成两步：先取完F(k−1)张牌，再取完F(k)张牌。对于F(k−1)张牌，先取A者输！意味着对于F(k)张牌，A还得必须先取，所以A输。 那么，牌数为非Fibonacci数时，先取牌者有没有必胜的策略呢？ 引用一个定理：当一个数不是Fibonacci数时，这个数必然等于若干个Fibonacci数之和，并且这些Fibonacci数在Fibonacci数列中都不相邻。 对于非Fibonacci数a，a=f(n)+…+f(i)+f(j) ，其中f(j)是式中最小的Fibonacci数，f(i)是第二小的Fibonacci数。 由于f(i)、f(j)在Fibonacci数列中并不是相邻的，所以f(i)&gt;2∗f(j)。所以先取者可以直接取走f(j)张牌，后取者无法一次取走f(i)张牌，f(i)是Fibonacci数，由前面的分析，后取者必败。 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; map&lt;int,int&gt;mp; void init() { ll a=1,b=2; mp[a]=1,mp[b]=1; for(int i=3;i&lt;100;i++) { ll c=a+b; a=b; b=c; mp[a]=1,mp[b]=1; } } int main() { int n; init(); while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) { if(mp[n]) printf(&quot;Second win\\n&quot;); else printf(&quot;First win\\n&quot;); } return 0; } 博弈论入门之nim游戏 有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利？ 面对新的博弈问题，我们按照套路，从简单的情况入手 当只有1堆石子的时候，先手可以全部拿走。先手必胜 当有2堆石子且石子个数相同的时候，先手不论拿多少，后手都可以从另一堆中拿同样多的石子，先手必败，否则先手必胜 当有三堆的时候呢？ 当有n堆的时候呢？ 这样玩下去确实是很繁琐，不过前辈们总结出了一条非常厉害的规律！ 当n堆石子的数量异或和等于0时，先手必胜，否则先手必败 证明如下： 设^表示异或运算 nim游戏的必败态我们是知道的，就是当前n堆石子的数量都为零 设a[i]表示第i堆石子的数量，那么当前局面就是 0 ^ 0 ^ 0 ^ … ^ 0 = 0 对于先手来说，如果当前局面是 a1 ^ a2 ^ a3 ^ … ^ an = k 那么一定存在某个ai，它的二进制表示在最高位k上一定是1 我们将ai ^ k，这样就变成了 a1 ^ a2 ^ a3 ^ … ^ an ^ k = 0 此时先手必胜 对于先手来说，如果当前局面是 a1 ^ a2 ^ a3 ^ … ^ an = 0 那么我们不可能将某一个ai异或一个数字后使得 a1 ^ a2 ^ a3 ^ … ^ an = 0 此时先手必败 例题 洛谷P2197 Nim裸题 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { int t;scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m=0;scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { int x;scanf(&quot;%d&quot;,&amp;x); m^=x; } if(m) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0; } POJ1704 好巧妙的Nim啊！！！ 首先我们想到一种必败态：即仅有两个点且相邻 那么我们可以把所有的点排序之后两两捆绑，这样如果A移动第一个，那么B可以把第二个移动相同的步数 这样我们就解决了顺序的问题 那么接下来就考虑如何解决博弈问题 这里有个神仙操作 把两点直接的距离看做一堆石子，然后请Nim来就可以啦 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int a[1005]; int main() { int t;scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m;scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a,a+n); if(n&amp;1) { m=a[0]-1; for(int i=2;i&lt;n;i+=2) m^=(a[i]-a[i-1]-1); } else { m=0; for(int i=1;i&lt;n;i+=2) m^=(a[i]-a[i-1]-1); } if(m) printf(&quot;Georgia will win\\n&quot;); else printf(&quot;Bob will win\\n&quot;); } return 0; } 变形 Moore’s Nim n堆石子，每次从不超过k堆中取任意多个石子，最后不能取的人失败。 这是一个nim游戏的变形，结论：把n堆石子的石子数用二进制表示，统计每个二进制位上1的个数，若每一位上1的个数mod(k+1)全部为0，则必败，否则必胜。 证明： 全为0的局面一定是必败态。 任何一个P状态，经过一次操作以后必然会到达N状态：在某一次移动中，至少有一堆被改变，也就是说至少有一个二进制位被改变。由于最多只能改变k堆石子，所以对于任何一个二进制位，1的个数至多改变k。而由于原先的总数为k+1的整数倍，所以改变之后必然不可能是k+1的整数倍。故在P状态下一次操作的结果必然是N状态。 任何N状态，总有一种操作使其变化成P状态。从高位到低位考虑所有的二进制位。假设用了某种方法，改变了m堆，使i为之前的所有位都回归到k+1的整数倍。现在要证明总有一种方法让第i位也恢复到k+1的整数倍。 有一个比较显然的性质，对于那些已经改变的m堆，当前位可以自由选择1或0. 设除去已经更改的m堆，剩下堆i位上1的总和为sum 分类讨论： sum&lt;=k-m,此时可以将这些堆上的1全部拿掉，然后让那m堆得i位全部置成0. sum&gt;k-m 此时我们在之前改变的m堆中选择k+1-sum堆，将他们的第i位设置成1。剩下的设置成0.由于k+1-sum&lt;k+1-(k-m)&lt;m+1,也就是说k+1-sum&lt;=m，故这是可以达到的； anti-nim反nim游戏 正常的nim游戏是取走最后一颗的人获胜，而反nim游戏是取走最后一颗的人输。 一个状态为必胜态，当且仅当： 所有堆的石子个数为1，且NIM_sum(xor和)=0 至少有一堆的石子个数大于1，且 NIM_sum(xor和)≠0 新Nim游戏 在第一个回合中，第一个游戏者可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。第二回合也一样，第二个游戏者也有这样一次机会。从第三个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。 如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。 为使后手必败，先手留给后手的必然是若干线性无关的数字，否则后手可以留下一个异或和为零的非空子集使得先手必败，故问题转化为拿走和最小的数字使得留下的数线性无关，即留下和最大的线性基，这样拿走的数量显然最少，找到和最大的线性基只需贪心的把数字从大到小加入到基中即可（证明需用到拟阵） bzoj3105 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int num[1005],d[1005]; bool cmp(int a,int b) { return a&gt;b; } int Insert(int k) { for(int i=31;i&gt;=0;i--) { if(k&amp;(1&lt;&lt;i)) { if(!d[i]) { d[i]=k; return 1; } else k^=d[i]; } } return 0; } int main() { int k;ll m=0; scanf(&quot;%d&quot;,&amp;k); for(int i=0; i&lt;k; i++) scanf(&quot;%d&quot;,&amp;num[i]); sort(num,num+k,cmp); for(int i=0; i&lt;k; i++) { if(!Insert(num[i])) m+=num[i]; } printf(&quot;%lld&quot;,m); return 0; } Nim游戏求方案总数 给定一个Nim状态，求该状态能够到达获胜状态的方案总数。 若该状态为P状态，则Nim和为零，肯定方案总数为0 若Nim和不为零，则表明该状态处于N状态，由于该位置是N位置，所以Nim和不为零，我们要求有多少总方案，改变其状态，使Nim和为零。 Nim和的求法为x1,x2,x3…xn的异或和，考察第一堆石头，设a=x1,b=(x2+x3+…+xn)，那么: Nim=a^b—————————1 假设改变a即第一堆石头的数目之后，新的Nim和为0,即: Nim’=a’ ^ b=0———————2 由于改变了石头的数目，必有: a’&lt;a———————————3 由方程1,2可以得到b=Nim ^ a = Nim’ ^ a’,又Nim’=0，故: Nim ^ a= a’————————4 将得到的方程4带入方程3，得到关系式： Nim ^ a &lt; a————————5 也就是说，对于每一堆石头来说，只要满足关系式5，则就一定可以通过将这一堆的石头的数目改变从而使新的Nim和为0，也就是从N位置转移到P位置。统计共有多少堆石头满足关系式5，就有多少种转移的方案啦。 poj2975 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int num[1005]; int main() { int n; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) { ll m=0;int ans=0; for(int i=0; i&lt;n; i++) { scanf(&quot;%d&quot;,&amp;num[i]); m^=num[i]; } for(int i=0; i&lt;n; i++) { if((num[i]^m)&lt;num[i]) ans++; } printf(&quot;%d\\n&quot;,ans); } return 0; } 2020 CCPC-Wannafly Winter Camp Day2 C 如何将上一题O(n^2)降为O(nlogn)？当然是位运算啦！ 因为 y &gt; x ^ y，所以y的最高位一定高于或等于x的最高位，否则x的最高位不变，不满足 考虑异或和的最高的为 1 的二进制位，所有这一位是 1 的 y 显然都满足条件，这一位是 0 的都不满足条件。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; int cnt[65]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); ll a,b=0; for(int i=0; i&lt;n; i++) { scanf(&quot;%lld&quot;,&amp;a); b^=a; ll x=a; int k=0; for(int j=0;x;j++) { cnt[j]+=x%2; x/=2; } ll sum=b; while(sum) { sum/=2; k++; } printf(&quot;%d\\n&quot;,cnt[k-1]); } return 0; } 博弈论入门之威佐夫博弈 有两堆石子，两个顶尖聪明的人在玩游戏，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取得人输，分析谁会获得胜利 定义先手必输的局势为奇异局势，前几个奇异局势为 (0,0),(1,2),(3,5),(4,7),(6,10)… 假设(x,y)为第k个奇异局势 性质： x为前1…k个奇异局势中没有出现过的最小正整数，y=x+k 任何一个自热数都包含在一个且仅有一个奇异局势中 证明有需要可以自寻，窝已经绕晕了QWQ 人们通过对上述性质的探索，同时结合Betty定理，给出了威佐夫博弈的重要结论 假设两堆石子为(x,y)（其中x&lt;y） 那么先手必败，当且仅当 (y−x)∗(√5+1)/2=x 其中的(√5+1)/2实际就是1.618…，黄金分割数！ POJ1067 #include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #define ll long long using namespace std; int main() { int a,b; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF) { if(a&gt;b) swap(a,b); int c=(b-a)*(sqrt(5.0)+1.0)/2.0; if(c==a) puts(&quot;0&quot;); else puts(&quot;1&quot;); } return 0; } 51NOD 1185 威佐夫游戏 V2 这题本来也是裸题，但是！ 可恶的出题人卡精度红红火火恍恍惚惚 然后我尝试了一下python3交 python真香~ from decimal import * from math import sqrt t=int(input().strip()) for case in range(t): a, b = map(int, input().strip().split()) p=Decimal((Decimal(5).sqrt()+1)/2) dif=abs(a-b) a=min(a,b) if a==int(p*dif): print(&quot;B&quot;) else: print(&quot;A&quot;)","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"/tags/博弈论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"dp专题","slug":"dp专题","date":"2019-12-16T11:51:38.000Z","updated":"2020-02-12T04:47:51.221Z","comments":true,"path":"2019/12/16/dp专题/","link":"","permalink":"/2019/12/16/dp专题/","excerpt":"这是我非常抗拒的一个算法点QAQ 因为真的很难 一直下意识地逃避不想学。 But最好面对恐惧的办法就是！疯狂刷题！！！ Yisin冲呀~ 感谢awen给我们开的套题。特此鸣谢~","text":"这是我非常抗拒的一个算法点QAQ 因为真的很难 一直下意识地逃避不想学。 But最好面对恐惧的办法就是！疯狂刷题！！！ Yisin冲呀~ 感谢awen给我们开的套题。特此鸣谢~ dp专题A - Sum of Different Primes题目传送门 以我拙劣的英语水平翻译一下是这样的：给你多组n和k，问用k个不同质数加和为n有多少种方案。 嘿咻！忽略掉质数和不重复两个关键词的话，这道题和《算法竞赛入门到进阶》（今年的一本新书，推荐，作者是华理的竞赛教练）dp入门的一题十分相似。 原题（hdu2069）如下：题目传送门 有n种硬币，面值分别为v1,v2,…,vn，数量无限。输入非负整数s，选用不多于100个硬币，使其和为s。输出所有可能的硬币组合。 那么我们可以定义一个矩阵元素dp[i][j]，含义是用j个硬币实现金额i的数量方案。 第一步：只用1分硬币实现初始dp[0][0]=1，其他为0。定义int type[5]={1,5,10,25,50}为5种硬币的面值。那么可以推导出来 dp[1][1] = dp[1][1] + dp[0][0] = dp[1][1] + dp[1-1][1-1] = 0 + 1 = 1dp[1-1][1-1]是因为从1分金额里减去1分硬币的钱，1个硬币的数量也减少了1个。 所以这一步实际上是dp[1][1] = dp[1][1] + dp[1-type[0]][1-1] 第二步：加上5分硬币，继续进行组合dp[i][j]，当i&lt;5时，组合里不可能有5分硬币。当i&gt;=5时，金额为i，硬币为j个的组合数量等价于从i中减去五分钱，而且硬币数量也减去1个的情况。dp[i][j] = dp[i][j] + dp[i-5][j-1] = dp[i][j] + dp[i-type[1]][j-1] 第三步：陆续加上10分、25分、50分硬币，同理有以下关系：dp[i][j] = dp[i][j] + dp[i-type[k]][j-1]，k=2,3,4 所以代码就是 //#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int type[5]={1,5,10,25,30}; int dp[251][101]; int n,k; void solve() { dp[0][0]=1; for(int i=0;i&lt;5;i++) { for(int j=1;j&lt;101;j++) { for(int k=type[i],k&lt;251;k++) { dp[k][j]+=dp[k-type[i]][j-1]; } } } } int main() { int s;int ans[251]={0}; solve(); for(int i=0;i&lt;251;i++) { for(int j=0;j&lt;101;j++) ans[i]+=dp[i][j]; } while(cin&gt;&gt;s) cout&lt;&lt;ans[s]&lt;&lt;endl; return 0; } 明白了这道硬币题，那么这道题的思路也是一样的。只不过给定的数需要自己求。数据最大是1120，所以打个素数筛轻而易举，将1120前所有质数放进type数组里面。 所以一开始我是这么写的 //#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int type[1005],ans=0; ll dp[2005][20]; int n,k; void init() { for(int i=2;i&lt;=1120;i++) { int flag=1; for(int j=2;j*j&lt;=i;j++) { if(i%j==0) { flag=0; break; } } if(flag) type[ans++]=i; } } void solve() { dp[0][0]=1; for(int i=0;i&lt;ans;i++) { for(int j=1;j&lt;=k;j++) { for(int m=type[i];m&lt;=n;m++) { dp[m][j]+=dp[m-type[i]][j-1]; } } } } int main() { init(); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)==2&amp;&amp;(n||k)) { mem(dp,0); solve(); cout&lt;&lt;dp[n][k]&lt;&lt;endl; } return 0; } 然后我发现事情并不简单，因为这个程序连样例也并不能完全通过。于是我开始了漫长的debug之路，最后找到了问题所在！这个程序是有可能取重复素数的，因为取硬币的时候并没有要求每种类型只能取一个，但是这题规定了一个素数只能被加一次。 辣么，解决方案是什么呢？ 让我们倒着来想。 dp[m][j]+=dp[m-type[i]][j-1]意味着： 当 type[i] 在 dp[m-type[i]][j-1] 的计算中已经有可能被使用的情况下仍然继续被使用。 那么，如果我们换成dp[m+type[i]][j]+=dp[m][j-1]，并让之前的加法倒转成一个减法呢？ 也就是如下的循环： for(int i=0;i&lt;ans;i++) { for(int j=k;j&gt;0;j--) { for(int m=n-type[i];m&gt;=0;m--) { dp[m+type[i]][j]+=dp[m][j-1]; } } } 一开始我也不太明白这个循环是怎么回事，后来观察了一下每一步的相加元素，就清楚了。一开始只有到dp[0][0]才能有值，所以只有dp[type[0]][1]才会有值。根据dp[type[0]][1]，所以dp[type[0]+type[1]][2]也会有值；再根据dp[0][0],dp[type[1]][1]也会有值……就完成了每个元素的全排列。已经被用过的值是不可能再被使用的。妙啊！ 所以这道题的最终程序是： //#include&lt;bits/stdc++.h&gt; #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int type[1005],ans=0; ll dp[2005][20]; int n,k; void init() { for(int i=2;i&lt;=1120;i++) { int flag=1; for(int j=2;j*j&lt;=i;j++) { if(i%j==0) { flag=0; break; } } if(flag) type[ans++]=i; } } void solve() { dp[0][0]=1; for(int i=0;i&lt;ans;i++) { for(int j=k;j&gt;0;j--) { for(int m=n-type[i];m&gt;=0;m--) { dp[m+type[i]][j]+=dp[m][j-1]; } } } } int main() { init(); while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)==2&amp;&amp;(n||k)) { mem(dp,0); solve(); cout&lt;&lt;dp[n][k]&lt;&lt;endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"梦碎石家庄","slug":"梦碎石家庄","date":"2019-11-18T11:35:26.000Z","updated":"2020-02-12T04:50:17.670Z","comments":true,"path":"2019/11/18/梦碎石家庄/","link":"","permalink":"/2019/11/18/梦碎石家庄/","excerpt":"渭城朝雨浥轻尘 客舍青青柳色新 劝君更尽一杯酒 西出阳关无故人 低吟白雪逢阳春 送君别去无知音 高台孤矗昂首望 穹凄尽兮宙宇敞 车马纵兮雁飞翔 春复秋往世无常 幽清默兮落暗乡 何年何月蹉跎降 莫问莫观你莫惆怅 山石林木无易样","text":"渭城朝雨浥轻尘 客舍青青柳色新 劝君更尽一杯酒 西出阳关无故人 低吟白雪逢阳春 送君别去无知音 高台孤矗昂首望 穹凄尽兮宙宇敞 车马纵兮雁飞翔 春复秋往世无常 幽清默兮落暗乡 何年何月蹉跎降 莫问莫观你莫惆怅 山石林木无易样两年前，诗词大赛上，我们从耻辱之队到所向披靡再到痛失冠军。但是那是我高三最幸福的时刻，我可以逃避那些堆积成山的试卷，可以逃避那昏昏欲睡的课堂，读着自己喜欢的诗，干着自己喜欢的事情。 被钉在耻辱柱上的那天，赛前，老师们信心满满，你们就随便玩玩，第一出线应该不难。然后，我们是出线了，但是是以最后一名的身份。那天我哭得很惨，在自己最喜欢的事情上输了，还是这样的惨烈。 应该答对的，我紧张，犹豫，答错了；加上诗词面实在窄，虽然在校内以第二的名次进入的校队，但是我读的诗大部分是喜爱其风格词句，集中度比较高。那天比赛前，我还非常高兴地喊了两个好朋友来看我比赛。等她们到的时候，比赛已经结束了，她们只看到哭成泪人的我在凳子上心如刀绞。 初战不利。于是指导老师想出了封闭式训练的办法。一个月为期，我们的目标是冠军。那个时候刚考完第一次选考，其实我有自己的私心，我不想囿于昏昏欲睡的课堂了，我想干点自己喜欢的。所以，即使我的父母，我的班主任他们所有人都在反对，我跟他们耗了很久，终于得到了折中的办法，重要的课例如数学课我必须去上，其他的随我自己。 那是多么快乐的日子啊！自由潇洒似神仙。而一起相处的人，都是一样热爱诗词的人，虽无流觞曲水之盛况，亦存以诗相和，以词相逗。老师也对我非常好，读诗词之余，他也单独给我讲一些提升语文成绩的办法，并且承诺我高三的语文他包了。 第二次出征的时候我们碰到的都是弱队，不费吹灰之力甩了第二名一百分的分差。那时的激动，现在想来也会微微一笑吧。 半决赛，我们碰到了强劲的对手——温岭中学。正如高考成绩上的针锋相对，赛场上我们都对对方虎视眈眈。双方最后平局，于是需要加赛一轮。我们中唯一的男生自告奋勇（但是后来因为这个又成为一件伤心的往事），一分之差险胜。但是赛后温岭中学质疑我们作弊，闹得沸沸扬扬。事情很快被平息，比赛的主持人（也是我非常喜欢的小哥哥）徐志那时候对他们说，没关系，以后你们终会站上更大的舞台。 是啊，多年以后，这时的一时得失又算得了什么。 决赛，其实我们的表现无功无过。妙手丹青、飞花令一样优势，但是答题上面不占优势，诗词常识的功底太浅了。三轮玩下来我们和回浦中学玩成了平局，所以需要加赛。其实后面的发挥就与我无关了。最后没有迎来奇迹，差一点也是差一点。 那个时候最欢乐的时光，虽然结局并非完美，但是已经很开心了。 两年后，本以为和这些绝缘的我遇到了另一个机会——河北省人文知识竞赛。我的心里有一个梦，我告诉自己，圆梦的时候来了。 出线省赛比我想象中容易。本以为自己好些年没触碰这些，会显生疏。但是有些东西印在脑子里，是忘不掉的。我的强项，大抵也就是诗词了吧。 去石家庄的那周刚好碰到大物考试，所以也没办法准备。当时想的是，反正就去玩一玩，我对拿奖其实没什么渴求，也就是想和大家切磋一下而已。 一考完大物我和其他两个男生就踏上了火车，去追赶大部队的步伐。第二天的笔试其实我自己感觉还行。跌跌撞撞我们闯进了半决赛。 当时其实我也像两年前那样期许自己能顺利晋级决赛。多么美丽的梦呀~那天晚上大家都很努力地在准备第二天的表演。emmmm其实我也说不上想台前还是幕后，我的抗压性有点差，所以就怕上台犯怂，最后让学妹上了，我旁白。 半决赛的可惜大概比两年前更难受吧（www 我还清晰地记得前面都是古诗词，我答的很顺手，然后出现了一句诗“梅子留酸软齿牙，芭蕉分绿与窗纱”描写的是哪个季节，我第一反应是“夏季”，写完了以后顺口问了大家一句要不要写“初夏”，然后大家都说不用，我就没有改。最后答案公布就初夏，夏季不得分。我当时真的超级大的失落感，白白葬送了十分。 还有一题是说河北的民间音乐，我们中有一个河北学长，他当时非常没有把握地说了一个“京韵大鼓”，然后本来想写了，另外一个妹子说了个“莲花落”，当时我们觉得她说的好像很有道理，然后就采用了她的答案。最后答案还是“京韵大鼓”。 表演环节我的电脑开始罢工，然后就白白耽误了五分钟左右。我当时真的很慌，感觉印象分绝对被拉低了。 其他组的题目都很正常，是历史事件之类的。只有我们是“丁是丁卯是卯”，像极了相声主题。我们很无奈，只能把这句话寓于我们的故事中，最后定下的《挥泪斩马谡》。 我们就止步于这里了。一如两年前。Yisin的梦大概是碎了，醒了，心里的花也死了。不知道明年有没有机会，但是再也不能这么肆意地去追逐这样的东西了。 我本楚狂人，凤歌笑孔丘。 红颜弃轩冕，白首卧松云。 醉月频中圣，迷花不事君。 可是， 欲闻华亭鹤唳，可复得乎 曾经它的结尾是问号。现在大抵是个叹号了。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"/tags/随笔/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"十月末の小记","slug":"十月末の小记","date":"2019-10-29T12:46:06.000Z","updated":"2020-02-12T04:52:14.046Z","comments":true,"path":"2019/10/29/十月末の小记/","link":"","permalink":"/2019/10/29/十月末の小记/","excerpt":"十月十月十月， 好像又陷入了悲伤的漩涡。 觉得自己一事无成， 觉得自己资质平庸。","text":"十月十月十月， 好像又陷入了悲伤的漩涡。 觉得自己一事无成， 觉得自己资质平庸。 十月末の小记十月恍恍惚惚就过到了月末。 感觉这个月好像经历了很多事情，但是却一事无成？ 月初国庆选拔赛拿到了去往上海的资格，实现了今年赛区“三过家门而不入”。然后五号一次团建，虽然饭菜并没有非常如意，但是和兔子的第一次集体旅行还值得一提。 然后迷迷糊糊就去了厦门。这个学期的第一站。然后，赛后本来还很激动地以为自己首战就可以拿铜，结果，铁首。厦门的悲伤不太想赘述，因为回忆起来真的十分难受。不敢置信，我们队如今实力居然还有可能打铁。这意味着我一直对我们的巨大憧憬幻灭了。 中间经历了一场大学物理波动与光学考试。其实这门课我已经算学得很认真了。平心而论，我认为跟大一学线性代数的状态差不多，一开始听得比较认真，只是后面跟的比较吃力，久而久之就有些气馁了。 但是感觉和周围人的状态相比还是偏努力一点？也许是方法的问题，学习这种理论性学科我向来缺乏经验。但是也不甘心直接撇弃。 考完以后的感觉就是重点其实全部都扫到了，但是由于复习的战线拉得过长，前面一些东西的印象不深，考试的时候脑子一片空白。但是其实考完感觉还可以，毕竟大部分都是那种一眼题，出错的概率还是很小的。 等待成绩的日子既紧张又轻松，既烦躁又开心。但是最后看到成绩的那刻人都不好了。不算差，比之前进步很多，然而比预期低了一些。问了一下室友的成绩，结果发现她的成绩也比我高了一截……（泪崩 于是最后，得知全年级九十分以上占比百分之六十。相对无言，唯有泪千行。 这件事的悲伤持续了很久，以至于我开始对自己产生怀疑。那年高考我对于计算机的选择是不是就是个错误。虽然高中一开始确实文理比较平均，没有特别出色的，然后为了追求成绩的最大化，田忌赛马式地选了历史政治技术，虽然也是真心喜欢这些科目，毕竟还是存了那些心思的。 感性，文艺，这些词一直伴随着我。就算在文科班，我的语文水平也是顶尖的，甚至最后我都是朝年级前几的语文成绩发起进攻的。我喜欢语文，我喜欢历史，我本可以岁月静好地留在省内读文学，但是，“今日长缨在手，何时缚住苍龙”？就是因为对黑客的向往，我背井离乡了，断了自己对文科的路。 时至今日，我仍然记得历史老师对我寄予的殷切希望。那是我高三最后的光。他说，相信我可以冲一冲浙大；每次考完试我总会缠着他帮我分析试卷；甚至最后，我和他聊理想，谈历史。我当初，也是很真心地喜欢这个老师，并且想成为和他一样的光。但是，最后我背叛了自己跟他说的梦想。 假如当初再努力一些……其实高考不选择文科不单纯是因为对计算机爱的深沉。只是文科的分数普遍高，而去一个不怎么知名的学校我也不愿意。放弃文科，第一痛苦的是另一个梦想，第二痛苦的就是现在被数理折磨。 然后，这个月的月底，进了河北省人文知识竞赛。参加这个比赛纯粹当放松，加分奖项我从来不缺，就当是为了当初被放弃的另一个梦想奋斗几周。高三的诗词大会，真真是最美好的时光。 又扯了好多呀。唉，悲伤的十月…… 但是还是要继续加油鸭！","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"月份小结","slug":"月份小结","permalink":"/tags/月份小结/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"CCPC厦门站团队赛后总结","slug":"CCPC厦门站团队赛后总结","date":"2019-10-27T09:24:32.000Z","updated":"2020-02-12T05:02:42.489Z","comments":true,"path":"2019/10/27/CCPC厦门站团队赛后总结/","link":"","permalink":"/2019/10/27/CCPC厦门站团队赛后总结/","excerpt":"人生如逆旅 我亦是行人","text":"人生如逆旅 我亦是行人 2019.10.20-2019CCPC厦门赛区赛后总结solved：2/12Rank：140/238，Iron Medal赛中解决的问题 A: 1:25:54 J: 04:57:37(-2) 赛后总结20188117 项溢馨 终于能好好回首这场比赛，赛后在火车上的那段时间躲在自己的悲伤里，不想再去触碰厦门的回忆。厦门打铁，运气不好是很小的一部分因素。如果用题目太难，有效队伍变少做借口，那只能说明水平实力不够。但是我觉得不管什么情况下，我们打铁也是不应该的。我和学长先读的题，我觉得G是签到，他看了J觉得有点麻烦。所以我们就一起开了G。确定了大致思路以后，泽铭代码写了一半的时候，我们看了一眼榜，可以说是胆战心惊。大概有几十支队交题，只有两个队过题，交G的全WA了，过的全是其他题。但是当时我们还抱着一丝侥幸，也许我们就能成为天选之子。第一发提交理所当然地WA了。但是当时也没有几个队伍过题，所以我们决定继续找G的问题，开始了漫长的Debug之路。事实证明，当时这个决策非常的错误，不仅延长了过第一题的时间，还炸了队伍的心态。整G进入疲劳期的时候，我们看了一眼榜，发现G的过题率真的很低，反而是A更像签到题。A题主要是读题比较麻烦，但是思路很简单，所以读懂了以后基本没有什么障碍。A过的时候不算太慢，大概中上水平。但是问题就在于接下来开哪题。一番商量过后决定兵分两路，泽铭负责J，我和学长继续找G的错误。期间两个人时常切换谁用电脑，但是最后泽铭写完交的时候并没有过。这种情况需要三个人一起找错误。但是由于我自己对J理解不深，所以和学长都支持先看G。浪费了大量时间。最后一小时泽铭看实在不行了，强制性地让学长一起看J。事实证明，还好泽铭当时的判断比较准确，最后十分钟左右，通过一遍一遍的寻找，泽铭终于发现是复制粘贴的时候忘记改个小地方了，偏偏所有样例都对了。恰巧那时候我手表停了，所以我以为还有可能把G一起过了。但是过了J后不久，比赛就结束了。这次比赛我的确犯了一些比较严重的决策错误。之前我们有过读了很多题但是写不了，耗费了读题时间的问题，所以这次我过于保守，没有在卡题的时候另开一题，我的责任挺大。而且没有做到答应jyf学长的鼓励队友，自己变成了一个自闭怪。若非泽铭最后的正确抉择，我们可能输得更惨。我自己的个人实力也确实在退步，究其根本是觉得自己不用做主代码手，所以松懈得很厉害。我自己在态度上也应该反思。确实感觉和大一时候的那种热情不太一样了。现在变得功利，变得想抱大腿，变得慢慢不那么喜欢ACM了。但是就像父亲说过的，自己选的路，得走完。把兴趣变成一项事业，有利有弊。你也许会变得更加充满动力，也许会变得逐渐厌恶这种生活。但是不管怎么样，已经不仅仅是兴趣了，不可以半途而废。可能有些太急于求成了吧。一想到学长即将退役，一想到黄金时期即将消逝，一想到自己前途渺茫。我自己本身就是一个会想很多的人，包袱太多。顺境还好，一旦逆境，可能真的会抑郁到崩溃。总之这次比赛真的是一个很好的教训。让我更清楚地认识到自己的本质。希望下次比赛可以轻松一点，有准备一点。 20187874 刘泽铭 感觉比赛时最大的问题就是没有找到状态。A题过了之后因为当时榜全都带向了G，就一直在死抠G。虽然后来我去写了J，但也因为最开始想法有问题，wa了一次后也没有在上面花太多心思。最后半小时一行一行读代码，才发现一个函数名写错了，改完就过了，觉得代码熟练度的问题很大。 不会打逆风的场，在中期顺风转逆风后，没有考虑去重新看榜（现场OJ不能直接查看每道题过题人数，只能看排行榜自己估计），也不敢再去读题，导致出题人数远多于G的H和D都没有读，直到结束还一直以为G是过题第三多的题。 比赛经验不足，开局读完G，看到榜上红一片的时候就应该果断放弃G，而不是头铁自信敲。 20177866 卢佳星 这次厦门站依旧白给了，感觉全队的状态不是很好，做题策略上有很大的问题，在之前，我们一直是同时开两道题，而在做两道题的人之间却缺少交流，思路不是很开阔，而这次在三个人同时卡住的情况下，我们却没有及时得换题，导致所有人的思维僵住了，做题效率非常的低。 我在开场是就读到了G题，在没有想明白的情况下，想当然的认为是一道简单的进制转换题，并且在榜上已经阵亡十多个队的情况下，还是没有意识到自己的思路存在问题。在写完带了几组样例之后才发现自己思路上的问题和题目中是正好卡了ull的范围的需要转换成大数，或者写高精度，由于不熟悉大数，写了很多奇怪的bug出来，还彻底把自己写懵掉了，导致自己完全的陷在那道题里了，以至于最后一直在挂机。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Coloring a Tree","slug":"Coloring-a-Tree","date":"2019-09-26T11:25:52.000Z","updated":"2020-02-12T05:52:38.276Z","comments":true,"path":"2019/09/26/Coloring-a-Tree/","link":"","permalink":"/2019/09/26/Coloring-a-Tree/","excerpt":"题目链接&lt;–点这里 这段时间写了好多dfs，感觉这题比较有挑战？看了眼题解才想到思路，然后代码实现感觉也不太简单……","text":"题目链接&lt;–点这里 这段时间写了好多dfs，感觉这题比较有挑战？看了眼题解才想到思路，然后代码实现感觉也不太简单…… Coloring a Tree题目链接&lt;–点这里 题目意思： 给你n个点，代表这一棵树有n个节点。第二行内容是建树的关系，从第二个节点开始的节点和父节点（上一个节点）相连， 例如：1 2 2 1 5 代表：节点2和节点1相连，节点3和节点2相连，节点4和节点2相连，节点5和节点1相连，节点6和节点5相连。 第三行内容是需要将各个点涂成的颜色，给这个树涂色，有这么一条原则就是给某一节点涂色，以其为根节点的子树也将变为相应的颜色，问你最终需要最少需要涂多少次颜色就可以满足题目要求。 解题思路：我们可以这样来思考，因为最后需要使所有的点都涂成要求的颜色，一定是按照从根节点到叶子节点遍历的涂色，但所有的点都遍历会造成浪费，我们只需要找出需要涂的点即可。 那么哪些点需要涂呢？我们发现只有那些最后要求的其父亲节点和本身不同色的需要涂色，因为需要向下改变自身颜色，那么只需要统计这样点的个数即可。 一开始我苦思冥想怎么建树，把层次关系可以弄明白。但是后来发现完全不需要，只需要记录每个节点的父节点是谁就好了。我采用的是结构体排序，每对父子节点都存两遍，改变先后顺序。之后从根节点开始，把所有存在父子关系的点都加入节点i的队列。再从根节点的队列开始遍历，把每个没有更新父节点的节点当成当前节点的子节点。 sum的初值是1，因为根节点肯定需要涂色。然后从2到n扫一遍，当前节点与当前节点的父节点是否属于一种颜色，不相同则sum++。 #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} struct Tree { int l,r; }t[20005]; bool cmp(Tree a,Tree b) { if(a.l==b.l) return a.r&lt;b.r; return a.l&lt;b.l; } int father[10005]; int color[10005]; queue&lt;int&gt;q[100005]; int main() { ios::sync_with_stdio(false); int n,ans=0; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) { int y; cin&gt;&gt;y; t[ans].l=i;t[ans++].r=y; t[ans].l=y;t[ans++].r=i; } for(int i=1;i&lt;=n;i++) { cin&gt;&gt;color[i]; father[i]=-1; } //cout&lt;&lt;1&lt;&lt;endl; sort(t,t+ans,cmp); for(int i=0;i&lt;ans;i++) { q[t[i].l].push(t[i].r); } for(int i=1;i&lt;=n;i++) { while(!q[i].empty()) { if(father[q[i].front()]==-1&amp;&amp;q[i].front()!=1) { father[q[i].front()]=i; } q[i].pop(); } } int sum=1; for(int i=2;i&lt;=n;i++) { if(color[i]!=color[father[i]]) sum++; } cout&lt;&lt;sum&lt;&lt;endl; return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"/tags/搜索/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"},{"name":"dsu","slug":"dsu","permalink":"/tags/dsu/"},{"name":"贪心","slug":"贪心","permalink":"/tags/贪心/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"走出舒适圈","slug":"走出舒适圈","date":"2019-08-21T02:55:27.000Z","updated":"2020-02-12T05:53:26.998Z","comments":true,"path":"2019/08/21/走出舒适圈/","link":"","permalink":"/2019/08/21/走出舒适圈/","excerpt":"我本身还是一个挺喜欢安逸的人，也从来厌恶自己不了解的领域，发自内心的害怕。 记得金学长曾经的签名是，走出舒适圈，远离垃圾人。或许挺对的吧。","text":"我本身还是一个挺喜欢安逸的人，也从来厌恶自己不了解的领域，发自内心的害怕。 记得金学长曾经的签名是，走出舒适圈，远离垃圾人。或许挺对的吧。看今年的小萌新们，难免有些感慨。 虽说严于律己，宽以待人，我可能还是那种除非彻底失望，否则还是更愿意把待人待己的标准放一致。我又不是什么神仙，我能做到的，大家也应该可以呀；我自己也做不到的，emmmm，那自然不能去强加在别人身上嘛。 出题这件事其实是很恼火的。两次一共贡献了八道题，每一次都找了好几个人验过题，力争难度中等。 也问过同高中的学弟，他觉得难度很ok，想一想在一个小时内还是可以写完的。何况我第二次还削了难度。 最后还是被吐槽出题太难。 是，要我出那种简单题确实做不到。我不觉得那些题目应该拿来给你们当作业，那个自己练习几遍就OK了，当作业的话就不存在动力了。dbq，我就是那种严以待人的人，和你们其他温柔的学长学姐不一样。我清楚地知道我现在的水平不是因为天赋多么多么高，而是学的时候把命拼上。 我也想过，自己去年为什么那么幸运呢？提前搭上ACM的车，暑假提前就刷了一个学期应该练习的题量。认识awen或许是一个偶然，但是进入ACM肯定是必然。可能参加训练营的大家也未必都想进入这个圈子，所以，我没有拿去年我写过的题的难度为难大家呀，只是一些大家不能直接想出来的程序，训练思维和代码能力。 只是我自己这段时间其实也挺颓的吧。不喜欢写自己不擅长的题，所以写来写去还在原地徘徊。知识盲区依旧很多。醒的也越来越晚。 而且，感觉，又有好朋友越走越远吧。虽然和兔兔在一起以后，确实也没有太多时间一起聊聊天了。而且现在明显感觉到了分歧，或许是我变了。算了，就当是我变了，也好过看着他变了。 希望都能走出舒适圈吧。 共勉。","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"生活记录","slug":"生活记录","permalink":"/tags/生活记录/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"【2019】【NEUQ-ACM SUMMER CAMP】第九次课程作业解题报告","slug":"【2019】【NEUQ-ACM-SUMMER-CAMP】第九次课程作业解题报告","date":"2019-08-11T09:12:36.000Z","updated":"2020-02-12T06:15:55.750Z","comments":true,"path":"2019/08/11/【2019】【NEUQ-ACM-SUMMER-CAMP】第九次课程作业解题报告/","link":"","permalink":"/2019/08/11/【2019】【NEUQ-ACM-SUMMER-CAMP】第九次课程作业解题报告/","excerpt":"我出题比较喜欢安一个有趣冗长的背景，考查思维的题目。 所以可能很多小盆友都自闭了。 下面奉上题解，请食用。求轻喷。","text":"我出题比较喜欢安一个有趣冗长的背景，考查思维的题目。 所以可能很多小盆友都自闭了。 下面奉上题解，请食用。求轻喷。 【2019】【NEUQ-ACM SUMMER CAMP】第九次课程作业解题报告兔子与快乐水读题使人快乐。 题目大意可以理解为三堆可乐，两个人轮流挑一堆，最后一堆随意分配。求最后分到最少可乐的那个人最多能分得多少可乐。 乍一看是道博弈论的题目，实际是简单的脑筋急转弯。 我们可以这样思考，求最大值，那么浪费一定是最少的。那么，我们可以先取三堆可乐中较少的两堆，分别记为x1,x2，剩下来的最大堆的可乐数目（x3）一定不小于前两堆可乐的差值，即x3&gt;=abs(x1-x2)。 那么我们模拟这个过程。第三堆先用来补前两堆的差值，剩余部分平分，加起来就是正确答案。 然鹅~ 不需要这么麻烦。上文说过，求最大值，那么浪费一定是最少的。我们尽力做到不浪费的方法就是尽可能平分这三堆可乐。所以实际上最后就是一个求⌊总和/2⌋的过程。这种做法的正确性证明其实就是上一种做法。 记得定义变量需要long long 此题over XD 兔子的加班表一维数组应用。 很多同学疑惑怎样才能求出连续的1。 其实很简单。可以设置一个maxn表示1的最大连续数量，ans表示当前连续1的数量。通过循环判断当前若是1，则ans+1；当前若是0，则把之前ans与maxn比较，更新maxn大小，并把ans重新置0。 至于如何实现首尾相接呢？ 提供两种思路。 开两倍的数组。把两份相同加班表依次存入数组，这样子自然就是上一份的尾巴接在了下一份的头上。而且题目保证一定存在0，所以无需担心如果全是1则需减半的情况。 可以记录从数组第一个元素开始（如果有）和以最后一个元素为尾（如果有）的1的数量，最后加在一起。 兔子与玫瑰花园一维数组应用。 此题三种解法，层层优化。但是由于最后一种解法树状数组和线段树知识点过分难，在此不做赘述。只讲基础的两种。 一，最简单暴力写法。 初始化数组point[n]为0。可以在每输入一个区间[l,r]的同时，通过一重for循环把point[l]到point[r]置为1。最后只需要i从0到n循环判断point[i]大小，若为0则ans++，最后输出ans大小即可。 二，优化写法。（较难，看不懂的同学可以跳过） 读入m组区间两端点left[i]和right[left[i]]，第二个数组存在的意义是使直接通过左端点的值，就可以得知右端点的值。然后依据left[i]的值对数组进行排序。 对排序好的point数组遍历，扩展重叠区间的左右，即right[left[i]]&lt;=left[i+1]，则把区间右端点从right[left[i]]扩展为right[left[i+1]]。直至right[left[i]]&gt;left[i+1]，则把上个区间内point赋值为1。 接下去的做法同一。 这种做法节约了对重叠区间重复赋值的时间，但是比较难以理解。希望学有余力的同学可以好好思索，而且第二种做法数组也可用结构体代替。 祝大家下一次作业都AK！","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"解题报告","slug":"解题报告","permalink":"/tags/解题报告/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"字符串算法之Manacher","slug":"字符串算法之Manacher","date":"2019-08-07T02:06:01.000Z","updated":"2020-02-12T06:16:55.800Z","comments":true,"path":"2019/08/07/字符串算法之Manacher/","link":"","permalink":"/2019/08/07/字符串算法之Manacher/","excerpt":"Manacher算法， 又叫“马拉车”算法， 可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串长度的问题。","text":"Manacher算法， 又叫“马拉车”算法， 可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串长度的问题。 字符串算法之Manacher之前一直都在不知所云地套板子。 直到今天，下定决心，要搞懂Manacher的原理。 然后，原来不过如此嘛XD 从最简单的判断回文的方法说起。 即拉出字符串中的每个子串，判断它们是否回文。 拉出子串需要O(n^2),判断是否回文需要O(n)，所以这种方法的时间复杂度是O(n^3)。 那么再精巧一点，我们可以从字符串中的每个字符下手，对于每个字符向两边扩展求回文长度。这样子，时间复杂度降到了O(n^2)。 我们是否可以找到一种O(n)的算法呢？答案是肯定的。 不考虑dp的方法，其实我们能从回文串本身得到一些启示。 例如： c a b a d a b a b 我们运用第二种方法对每个字符进行分析。 从第二位a开始，b≠c，因此f[2]=1; 第三位b，c a b a d a b a b，因此，f[3]=3； 第四位a，b≠d，f[4]=1； 第五位d，c a b a d a b a b，因此，f[5]=7； 下面！！！高能！！！ 第六位a，b≠d，f[6]=1。但是！是不是觉得似曾相识？对！由于回文串具有对称性质，所以事实上，因为第四位构不成回文串，所以与此对应的第六位也是不可能有的。 第七位b，同理，第七位等同于第三位，f[7]=f[3]=3； 第八位a，是不是要脱口而出f[8]=f[2]=1？等等！我们发现 c a b a d a b a b ，因此，f[8]=3。这是为什么呢？由于s[1]≠s[9]，所以f[8]和f[2]是不一定相等的。 这样一个分析过程，实际上就是Manacher算法所需要做的。 首先，我们要记录下目前已知的回文串能够覆盖到的最右边的地方 同时，覆盖到最右边的回文串所对应的回文中心也要记录 以每一位为中心的回文串的长度也要记录，后面进行推断的时候能用到 对于新的中心，我们判断它是否在右边界内，若在，就计算它相对右边界回文中心的对称位置，从而得到一些信息，同时，如果该中心需要进行扩展，则继续扩展就行。 但是这样会出现一些问题，比如回文长度为偶数的时候，不存在严格意义上的回文中心。所以我们需要对字符串先进行一波预处理。 先对字符串进行预处理，两个字符之间加上特殊符号# 然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整） 每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度 判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界 最后得到最长回文之后，去掉其中的特殊符号即可 下面放上我觉得比较完美的一个板子 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; const int maxn = 2e5 + 10; char s[maxn], sNew[maxn&lt;&lt;1]; int p[maxn&lt;&lt;1], id, mx=0; int L, R; //回文串在原串的左右端点位置 int Init() { int len = strlen(s); sNew[0] = &#39;$&#39;; sNew[1] = &#39;#&#39;; int j = 2; for (int i = 0; i &lt; len; i++) { sNew[j++] = s[i]; sNew[j++] = &#39;#&#39;; } sNew[j] = &#39;\\0&#39;; return j; } int Manacher() { int len = Init(); int max_len = -1; mx = 0; for (int i = 1; i &lt; len; i++) { if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); else p[i] = 1; while (sNew[i - p[i]] == sNew[i + p[i]]) p[i]++; if (mx &lt; i + p[i]) { id = i; mx = i + p[i]; } if(max_len &lt; p[i]) { max_len = p[i]; L = (i - p[i])&gt;&gt;1; R = (i + p[i] - 4)&gt;&gt;1; ///R = (i + p[i])/2 -2; } } return max_len; }","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"/tags/字符串/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"字符串算法之hash","slug":"字符串算法之hash","date":"2019-08-05T01:36:58.000Z","updated":"2020-02-12T05:54:17.064Z","comments":true,"path":"2019/08/05/字符串算法之hash/","link":"","permalink":"/2019/08/05/字符串算法之hash/","excerpt":"Hash，一般翻译做”散列”，也有直接音译为”哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。","text":"Hash，一般翻译做”散列”，也有直接音译为”哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 字符串算法之hash我还是觉得hash好神奇。这到底是什么鬼东西啊喂！ 首先推荐三篇入门博客，我觉得写的十分精妙~ hash入门 hash进阶：使用字符串hash乱搞的姿势 字符串hash入门 这三篇博客已经基本把hash的前世今生交代清楚了。我再补充一点自己对hash的浅薄认识好了。一千个读者心中有一千个hash。众所周知，hash就是乱搞。hash是一种加密解密规则，类似于破译密码的一个过程。 我们对于子字符串每位进行一波操作，并不断累加。其关键步骤就是 h[i]=h[i-1]*base+s[i] 由此我们可以得到每个字符串对应的值。但是，hash冲突的产生就是这个值可能不是一一对应的，一个值也许对应了多个字符串。 尽量避免hash冲突的关键就在于对base这个进制以及模数的选择上，base一般选择大于字符串中的最大的字符且不含模数的值因子的数。 比如说，如果你是对一串小写字母做字符串hash，那么131这个进制就是不错的选择。 而模数的选取方式一般分为三种： 选择两个模数，判断的时候只有两个hash值都相同才算相同 选择一个大质数，像11111111111111111111111或者212370440130137957 用unsigned long long 自然溢出 那么区间hash值如何计算呢？ 因为hash实质上是将字符串进行进制转换的过程，所以对于区间内的hash值就是整体值去左去右分别对应的转换好的进制值。用公式表达就是这样子： ll get_hash(int l,int r){&emsp;&emsp;return h[r]-h[l-1]*p[r-l+1];} p[n]代表base的n次方。","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"/tags/字符串/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"戊戌变法剧本","slug":"戊戌变法剧本","date":"2019-05-29T16:58:03.000Z","updated":"2020-02-12T05:22:09.779Z","comments":true,"path":"2019/05/30/戊戌变法剧本/","link":"","permalink":"/2019/05/30/戊戌变法剧本/","excerpt":"高三时候看了一丢丢《北京法源寺》。 实在是令人拍案叫绝。 谨以此篇致敬李敖先生。","text":"高三时候看了一丢丢《北京法源寺》。 实在是令人拍案叫绝。 谨以此篇致敬李敖先生。 戊戌变法——改编自话剧《北京法源寺》，致敬李敖先生 人物： 戊戌六君子 谭嗣同，湖南人 （康广仁，广东人） 林旭，福建人 杨深秀，山西人 杨锐，四川人 （刘光第，四川人） 慈禧 光绪 袁世凯，河南人 康有为，广东人 梁启超，广东人 （建议按照地域选择人物，剧本偶有几句方言效果较好） （bgm1：《知否知否》起） 旁白：中国的近代史是一部屈辱史、抗争史、同时也是一部探索史。面对着帝国主义列强的大肆入侵和疯狂瓜分，中国人民在思索着寻找一条救亡图存之路，在帝国主义的隆隆炮声中，戊戌变法拉开了帷幕，国仇、家恨、抱负、野心也在这短短百日展现得淋漓尽致…… 第一幕 旁白：戊戌政变时，以慈禧太后为首的封建顽固派大肆捕杀维新党人，维新志士谭嗣同、康广仁、林旭、杨深秀、杨锐、刘光第六人于1898年9月28日在北京惨遭杀害，史称“戊戌六君子”。时人面对着变法失败的结局与危机，纷纷做出了自己的选择。 （bgm1终） 谭嗣同：我叫谭嗣同。戊戌年，我33岁。我想以我个人之躯，打破数亿国众的意识桎梏。而睁眼看看，保全自己是目前大多数人的选择，而我却选择一条极少有人走的道路——殉！ （PPT：殉 加个闪电音效） 杨锐：我是杨锐，戊戌变法重要人物之一。四川绵竹的（方言）。 杨深秀：我叫杨深秀，戊戌变法重要人物之一。我是山西的（方言）。 林旭：我是林旭，戊戌变法重要人物之一。我是福建人（方言）。 合：我们四个，砍头时间一致。1898年9月28日。 旁白：1890年，康有为梁启超认识时，梁启超才18岁，正当风华正茂的时候；而当时康有为已经33岁了。他们亦师亦友，一起领导了戊戌变法。我想知道他们为什么生，为什么死？ 康有为：我是康有为。我是广东人（粤语）。 梁启超：我叫梁启超。我选择生，看见现世，推动发展。 杨锐、杨深秀、林旭：我们选择病。国家病了，人也就病了。国病，人病，还有心病。 谭嗣同：我选择死。冥阳一隔，穿入自由！ 第二幕 （bgm2：《风起时》起） 旁白：康有为，一个以重建治道自命，苦心钻研政体，当属宰相之才，无奈沦落体制外的名士知识分子，从来自负宏大的目标与责任，认定弘道护国治国兴邦，兴利除弊圣徒使命非他一人。康有为，自幼通天理、好易学，苦读圣贤之书，以圣人转世自居。康有为，年轻游历香港内地，研读大乘佛教经典，弘扬普济救世之论。康有为，作为圣贤与救世的结合体，深情热爱着几千年的古国帝制，热情体恤着民族苍生。 （bgm2终） 康有为：我，曾以我卓越的学识和区区个人之体，救助过满目疮痍的大清。我曾七次上书朝廷，第一次六千字，第二次一万七千字，第三次一万五千九百四十一字。我见到了皇上，这一个时辰让中国历史有了意义。 （bgm3：《妖谭》起） 旁白：戊戌变法时，光绪帝推动了一系列的改革，涵盖政治、经济、军事、文教等领域，包括拟定宪法、开制度局、禁止妇女缠足、裁冗官、置散卿、废漕运、撤厘金、裁绿营、放旗兵、废八股试帖楷法取士、改书院、废淫祠等；要求保护工商业，要求重练海陆军……改革的事业蒸蒸日上，而这些都起源于一次简单的君臣相谈。 （bgm3终） 光绪：提倡民主思想。这是康有为对朕说的第一句话。平等看待世界，做观念的强人。这是他对朕说的第二句话。让顽固守旧的份子和封建官制，受到一次前所未有的威胁和挑战。但是，不是推翻。破固有之陋习，立济世之新学。变法维新，努力发奋，大振皇基。 康有为：皇上圣明！臣终于盼到了大清维新的曙光。呵护新政，我康有为在所不辞。 旁白：他们忘了戊戌变法一个重要人物，出卖变法重要人物，没有之一。 袁世凯：我，袁世凯。我是戊戌变法重要人物之一。（以下为方言）俺，袁世凯，俺与你康有为相识二十一年，共为好友三年。对西方宪政的认识，你我亦有相近之处。袁某钦佩你的胆力才华，谏言大清。我按月薪水二十两，一次性拿出了五百两，支持你维新变法。就是因为我认为，大清不改，不能有出路。再这样下去，大清就去球了！ 第三幕（bgm4《我是人家最招摇》起） 旁白：1898年（光绪二十四年）9月底光绪帝去天津阅兵时，慈禧太后等人早有密谋，发动兵变，废黜光绪帝，打算一举扑灭新政。为了挽救变法事业，谭嗣同密会新军统帅袁世凯。袁世凯假意向谭嗣同妥协，百般敷衍，并且打算在背后告密，难道谭嗣同看不出来吗？至此，谭嗣同也终于明白了自己真正的使命…… （bgm4终） 谭嗣同：维新阵营里人人都想有所作为。 袁世凯：可这些人物里，没有一位是实权派人物。手下连一支敢死队都没有。谭章京，您的成功率几乎是零。 谭嗣同：你作为新军统帅 袁世凯：我作为新军统帅 谭嗣同：戴着一副假面具 袁世凯：面具下谁能看出我的忠诚和隐忍 谭嗣同：外表开明实则保守，骑墙之徒。 袁世凯：是我，是历史，让谭章京这位四品大员，提早结束了政治生涯。 谭嗣同：你们杀掉的是我的肉身，我将灵魂驻世，后代传扬。 袁世凯：我的好名声，死在了戊戌年9月28日。 谭嗣同：我要面对的，是陈腐的政治制度；我要挑战的，是陈腐政治制度下，庞大的利益集团。 第四幕 （bgm5《周郎》起） 旁白：慈禧，这个中国历史上最后一个封建王朝清王朝末期的实际统治者，中国近代史上几乎每一件丧权辱国的事件都与之息息相关。戊戌政变是慈禧太后一生当中发动的第三次宫廷政变，第一次是1861年11月同恭亲王奕訢发动的辛酉政变，第二次是1884年4月懿旨罢斥恭亲王为首的全部军机处成员而以醇亲王代之的甲申易枢，三次政变都以慈禧太后的胜利而告终，也都成就了她垂帘听政的政治野心。 （bgm5终） 康有为：她是镇压戊戌变法重要人物，没有之一。她是个妖魔，诡诈阴险，权利心极重，杀人不眨眼。她杀了我亲弟弟，康广仁。 杨锐：菜市口六君子人头落地，国仇家恨于一身。我对她恨之入骨。 杨深秀：她是个泼妇。 林旭：她是个恶妇。 康有为：她是个阻挠变法，把中国推向黑暗的罪魁。 旁白：你想了解历史，不能以几种或者某种历史观来看待她。恶贯满盈的慈禧太后是否可能在为了一己私欲的政变中稍微考虑过国家利益呢？她是一个女人，一个非凡的女人。维新派对慈禧恶语相向，这是自然的，慈禧是维新的最大阻力。而慈禧太后对于变法自然也有自己的想法。 （Bgm6：《清平调》起） 慈禧：我身后，是一片惶惶然的大清版图。维新派，全变大变的急进变革主张，造成朝野内部结构和清朝社会结构的强烈震荡。百日维新期间，上谕达一百八十四件之多，几乎一天一个新策，全国百姓目不暇接。皇帝严惩阻挠变革的朝廷官员，操之过急，树敌深重。废除八股，改革科举制度，令庞大的士人群体引起普遍的恐慌。 有关国计民生，亦是无论新旧，皇帝都不得因噎废食。只除旧迎新，造成朝廷官员恐慌掣肘只谈守旧。大清又无力变法，需皇帝谨慎处之，平衡发展。变法岂是几日可得，需皇帝拼尽余生，忍耐智取。而宵小之徒，窃变法之说、煽乱之谋，我必不饶之。 皇上，你要爱国。你没有实权，怎么爱国？你这个聪明的孩子，就是没有考虑到这核心的危险。皇帝，你会成为大清最愚蠢的叛徒。 （Bgm6终） 第五幕 （Bgm7：《破阵曲》） 旁白：维新派担心掌握军权的荣禄先动手，计划武力夺权。他们准备利用正在天津训练新军的袁世凯，让他夺取荣禄兵权，然后带兵进京，包围颐和园，将西太后捕杀，这就是康有为的“围园杀后”之计。这就促使西太后从颐和园赶回紫禁城，抓捕康有为等维新派。袁世凯的告密，加剧和扩大了西太后的镇压行动。这样，维新变法不可避免地失败了。1898年9月19日，慈禧太后从颐和园返回西苑，瀛台问罪光绪皇帝。 （bgm7终） 慈禧：拟旨，宣布戊戌变法为戊戌政变。缉拿新党，新法尽废，恢复旧法。 杨锐：大人如见，重大事件。我即将被捕，罪名深重。恳请大人速想良策，拯救学生杨锐。 林旭：大人如见，本人与维新派一并垢罪，触及林旭性命。望大人速想良策。 杨深秀：大人如见，维新重创，即将累及深秀本人。深秀罪名不定，或可重判。 谭嗣同：大人如见，旧势力反扑，我命在旦夕。谭嗣同不求营救特此禀告大人。 梁启超：跟随康先生我参加了戊戌变法，成为了我想成为后世传颂的中国思想改良者。我没有做先驱，没有因为哪一场改革丧命，我是个幸运也不幸的人。幸运的是，我结识了谭嗣同和三个为变法而死的军机章京。我也经历过了灾难最深重的国运。作为一个幸存者，这个国家我必须去救。不幸的是，我失败了。虽然屡战，还是屡败。我想，谭嗣同。 谭嗣同：我以我血荐轩辕。谭嗣同支持皇上矢志变法，不以死者无以酬圣主，不以行者无以图将来。救亡图存！如果维新阵营里，我们这些人全都走了，变法就会成为一个笑话。这局棋里，有一步死棋，就是我。 当我必须面对死亡时，我必须找到一个必须去死的理由。作为变法人士，变法失败了，我有殉难的义务。可是我想对着这个国家呐喊，不变法、不图强就是灭亡吗？不变法、不图强必然灭亡！变法之中一定会遇到一些问题，可那都不是事。因为不图强就消亡！ 杨锐、林旭、杨深秀：不变化，不生长；不图强，就消亡！ 杨锐：这就是我支持皇上变法的事业！ 林旭：绝望的不是我，绝望的是大清！ 旁白：戊戌政变时，以慈禧太后为首的封建顽固派大肆捕杀维新党人，维新志士谭嗣同、康广仁、林旭、杨深秀、杨锐、刘光第六人于1898年9月28日在北京惨遭杀害，史称“戊戌六君子”。 变法失败了，六君子身死，康、梁仓促出逃，维新派也被打压，几近灭亡。然而，这又何尝不是一种觉醒呢？谭嗣同在狱中写到—— （bgm8《狱中题壁》起） 朗诵：望门投止思张俭，忍死须臾待杜根。我自横刀向天笑，去留肝胆两昆仑。 旁白：在维新派的影响下，无数年轻人觉醒，走上了救亡图存的道路，从改革到革命，从和平到武力，救国的道路越来越宽，终有一天会取得胜利。 （bgm8终）","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"文学","slug":"文学","permalink":"/tags/文学/"},{"name":"剧本","slug":"剧本","permalink":"/tags/剧本/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"HBCPC河北省赛解题报告","slug":"HBCPC河北省赛解题报告","date":"2019-05-27T07:20:12.000Z","updated":"2020-02-12T06:17:44.460Z","comments":true,"path":"2019/05/27/HBCPC河北省赛解题报告/","link":"","permalink":"/2019/05/27/HBCPC河北省赛解题报告/","excerpt":"之前的游记过于花里胡哨，省赛题解的话另开一个好了 :-） 不知道什么时候能写完以及会写到哪里。 佛系小仙女（其实真相是太菜了，难题是既会写又不会写的~","text":"之前的游记过于花里胡哨，省赛题解的话另开一个好了 :-） 不知道什么时候能写完以及会写到哪里。 佛系小仙女（其实真相是太菜了，难题是既会写又不会写的~ HBCPC河北省赛解题报告封面图是省赛穿的小裙裙QWQ “女装”参赛然后被捶得有点难过。G、K too easy，我就直接跳了。 H.天神的密码 199/528这题也很水。（因为题目给了k的限定，不然就涉及到大整数快速幂）啥也不说了，放个代码。 注意不要使用pow函数计算，pow返回的是double类型，会掉精度。 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { ll n,k; cin&gt;&gt;n&gt;&gt;k; int sum=0; if(k==2) n*=n; while(n) { sum+=n%10; n/=10; } while(sum&gt;=10) { int sum1=sum; sum=0; while(sum1) { sum+=sum1%10; sum1/=10; } } cout&lt;&lt;sum&lt;&lt;endl; } return 0; } &nbsp;当N \\leq 10^{9},K\\leq 500时：因为(10^{9})^{500}只有4500位，使用高精度乘法模拟即可。&nbsp;当N \\leq 10^{1000000}, K\\leq 10^{18}时：考虑这个过程的性质，设某个数N的第i个数位的数字为N[i],可以知道：N \\, mod\\, 9=N[1]10^{k}\\,mod 9+N[2]10^{K-1}\\,mod 9+…+N[k]\\,mod 9=N[1]+N[2]+N[3]+…+N[k]也就是说，对于某个数字N来说，他的所有的数位上的和对9取模等于数字N对9取模。设第i次操作后的值为y_{i},我们可以知道N^K \\, mod \\,9 = y_{1} \\,mod \\,9=y_{2}\\, mod \\,9=y{3}\\,mod\\,9 =…=y_{n} mod \\,9由此，可以得知：题目中对于数字X=N^K进行变换的过程等价于令N^K对9取模,使用快速幂计算即可。 B.icebound and sequence 27/720 S = (\\sum_{i = 1}^{n} \\ q^i) \\ mod \\ p \\ (1 \\leq n,p,q \\leq 10^9) 简单想法直接模拟，复杂度 O(n) ，n 太大会 TLEsolution 1考虑等比数列的性质，如果我们想要计算S=q^{l}+q^{l+1}+\\cdots+q^r，我们可以先计算S’=q^{0}+q^{1}+\\cdots+q^{r-l}，然后整体乘上q^l,即S=S’q^l。利用这个性质，我们使用递归分治法解题。假设递归的这一层我们需要计算 T=(\\sum_{i=1}^b q^i)\\,mod \\,p ，我们先递归计算 T’=(\\sum_{i=1}^{\\lfloor b/2 \\rfloor} q^i)\\,mod \\,p ，将得到的结果乘上1+q^{b}，则得到S=T’(1+q^{b})=q+q^{2}+\\cdots+q^{\\lfloor b/2 \\rfloor2}。因为最后一项为向下取整再乘二，如果b为奇数的时候还需要再加一个q^{b}。全程注意取模！对于每一层我们都像上面那样递归，每一层都需要使用快速幂计算，共有logn层，总复杂度为O(lognlogn)，如果我们每层都记录一个参数Q=q^b，,则无需快速幂，总复杂度为O(logn)solution 2令s[i]表示等比数列前i项的和，则s[i]=s[i-1]*q+q，这是一个线性常系数递推式，可以使用矩阵快速幂处理递推。solution 3根据等比数列求和公式：当p \\neq 1时，S = (\\dfrac {q^{n + 1} - 1} {q - 1} + 1) \\ mod \\ p由于 p 可能为合数，(q -1)在模 p 意义下可能不存在逆元所以要改变一下模数，先将模数改为 p’ = p \\times (q - 1) ，计算模 p’ 意义下的答案 S = a \\times p’ + b ，由于 ，S，a 能被 (q - 1) 整除， 故 b 能被 (q - 1) 整除，就可以不用求逆元 我直接套了邝斌巨巨的板子，快速幂+递归 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; ll n,MOD,q; ll pow_m(ll a,ll n) { ll ret=1; ll tmp=a%MOD; while(n) { if(n&amp;1) ret=(ret*tmp)%MOD; tmp=tmp*tmp%MOD; n&gt;&gt;=1; } return ret; } ll sum(ll p,ll n) { if(p==0) return 0; if(n==0) return 1; if(n&amp;1) return ((1+pow_m(p,n/2+1))%MOD*sum(p,n/2)%MOD)%MOD; else return ((1+pow_m(p,n/2+1))%MOD*sum(p,n/2-1)+pow_m(p,n/2)%MOD)%MOD; } int main() { int t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;q&gt;&gt;n&gt;&gt;MOD; if(sum(q,n)==0) cout&lt;&lt;MOD-1&lt;&lt;endl; else cout&lt;&lt;sum(q,n)-1&lt;&lt;endl; } return 0; } C.分治 25/171区间 dp用 dp[i][j] 表示攻打完第 i 个国家到第 j 个国家共 (j - i + 1) 个国家需要的最小花费第一层循环枚举区间长度，第二层循环枚举区间左断点，第三层循环枚举最先攻打区间 [i, j] 内的城市k。则状态转移为 dp[i][j] = min { dp[i][k - 1] + dp[k + 1][j] + (j - i) * cost[k] } 复杂度是 O(n^3)&nbsp; #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int dp[105][105]; int cost[105],n; int main() { int t; cin&gt;&gt;t; while(t--) { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;cost[i]; memset(dp,0x3f,sizeof(dp)); for(int i=1;i&lt;=n;i++) dp[i][i]=0; for(int len=2;len&lt;=n;len++) { for(int l=1;l+len&lt;=n+1;l++) { int r=l+len-1; for(int i=l+1;i&lt;=r-1;i++) { dp[l][r]=min(dp[l][r],dp[l][i-1]+dp[i+1][r]+(r-l)*cost[i]); } dp[l][r]=min(dp[l][r],dp[l][l]+dp[l+1][r]+(r-l)*cost[l]); dp[l][r]=min(dp[l][r],dp[r][r]+dp[l][r-1]+(r-l)*cost[r]); } } cout&lt;&lt;dp[1][n]&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"/tags/题解/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"Codeforces Round #560 (Div. 3)","slug":"Codeforces-Round-560-Div-3","date":"2019-05-15T14:08:07.000Z","updated":"2020-02-12T06:30:23.920Z","comments":true,"path":"2019/05/15/Codeforces-Round-560-Div-3/","link":"","permalink":"/2019/05/15/Codeforces-Round-560-Div-3/","excerpt":"想哭，觉得没有意义 想睡，根本没有心情 cf头一次打得这么烂 然后又是大片大片的回忆 被保护着宠爱着成长的开始 吃不了太多苦的一路 总是对算法一曝十寒 一向觉得自己的思维能力出类拔萃 原来不过尔尔 可不就是个平凡么 又是哪来的自信来说 江东子弟多才俊的呢？ 抑郁少女唯一的光 只剩下你了","text":"想哭，觉得没有意义 想睡，根本没有心情 cf头一次打得这么烂 然后又是大片大片的回忆 被保护着宠爱着成长的开始 吃不了太多苦的一路 总是对算法一曝十寒 一向觉得自己的思维能力出类拔萃 原来不过尔尔 可不就是个平凡么 又是哪来的自信来说 江东子弟多才俊的呢？ 抑郁少女唯一的光 只剩下你了 Codeforces Round #560 (Div. 3)恍若梦游。 这几天又是那种浓稠的，深深把自己嵌进去的那种绝望。特别是打完这场cf，发现自己睡不着了。想了很多事情，包括一开始的时候意气风发，结果还不是要承认现实，承认平庸。 想热爱这个世界。却有些无能为力。最近单曲循环的一首歌唱得好哇：“有人会爱上我吗？这样忐忑懵懂的。这个人和那个人都沉默。他们不喜欢我，他们都不喜欢我。不是完美的我，只在意你的我。我知道你会是那一个，那个会擦干我泪水的，那个会永远不离开的，那个在墓地前种下栀子花掩埋我的，那个和我一起挣脱的，那个和我一起被俘的，那个为我阻挡全世界，我会付出生命的。” 欸，偏了偏了。不应该说这些的，下面还是正经一点来题解叭。 A.Remainder题意为给出一个非常大的十进制数字（只由0和1构成，首位一定为0）。问最少需要对几位数位的进行改变，使这个数对10^x取模的值等于10^y。 我读了好久的题目。读懂已经是好久后的事情了…… 我的想法很简单，直接从字符串后数x位，1只能出现在里面的后数y+1位置，只需要顺序查找就好了。 As we can see, last x digits of the resulting number will be zeros except the n−y-th. So we need to change all ones to zeros (if needed) among last x digits, if the position of the digit is not n−y, and change zero to one (if needed) otherwise. It can be done with simple cycle. 贴代码 #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int main() { ios::sync_with_stdio(false); int n,x,y; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y; string s; cin&gt;&gt;s; int ans=0,ans1=0; for(int i=n-x;i&lt;n;i++) { if(i==n-1-y) { if(s[i]==&#39;0&#39;) ans1++; } else { if(s[i]==&#39;1&#39;) ans1++; } //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;ans1&lt;&lt;endl; } cout&lt;&lt;ans1&lt;&lt;endl; return 0; } B. Polycarp Training读题一时爽，一直读错一直爽…… 这题题意就是给出每种类型书的数量，有个变态，要求自己第i天一定要读i本相同类型的书，并且读完以后相同类型的书不能再读。","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"CF","slug":"CF","permalink":"/tags/CF/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"四五月小记（2050团聚+HBCPC省赛）","slug":"四五月小记（2050团聚-HBCPC省赛）","date":"2019-05-12T11:43:08.000Z","updated":"2020-02-12T06:28:18.266Z","comments":true,"path":"2019/05/12/四五月小记（2050团聚-HBCPC省赛）/","link":"","permalink":"/2019/05/12/四五月小记（2050团聚-HBCPC省赛）/","excerpt":"江东弟子多才俊 卷土重来未可知","text":"江东弟子多才俊 卷土重来未可知 四五月小记（2050团聚+HBCPC省赛）这段时间都很忙，各种事情全都堆过来。加上自己比较穷，很多时候身不由己，难受极了。现在才来更博，主要是记录一下四月末五月初这段时间的一些日常。最主要的是回杭州参加2050团聚和刚刚结束的HBCPC省赛。 2050——预见更美好的自己如果申请不下来travel award，我应该就去不了2050，但是通过王老师的“py一下”，我的申请其实批得很早。（王老师后来还问我咋不多报一点） 当时肝了一晚肝出了一篇申请，自己写得都有些难受。想着以情动人，当时每当回首过去，总是有很多不甘。 申请的主体大概长这样子（被王老师放作范文了QAQ） 抱着想见见世面+见wls+回家+逃掉运动会的心态，很开心地踏上了回杭州的旅程。 见到你们很开心~ 第一次看到活的zjt小哥哥，和想象中差不多嘿嘿嘿。向小哥哥道歉，我们赖床太严重了，咕咕咕了两个早上。希望以后能继续一起加油，一起进步~The most important，一起cf开黑呀！ wls!就是他对小迷妹好冷淡呀www亲亲抱抱举高高都不敢，只能要合照啦。希望未来能和他一样厉害，看到一样的风景，然后一览众山小。 那晚一起恰饭饭。wls又抢着买单了。嘤总是觉得他和小天使一样善良，对世界充满善意。然后，一个重大发现，一桌子人只有我和他吃火锅不蘸任何蘸料的。大概浙江人的口味高度一致~ 还有感谢小姐姐的夸奖，女生赛再见呀！ 附：回家吃喝玩乐都很开心~最最最重要的是，wls问候我啦~超级爆炸无敌开心~ HBCPC——Know nothing but WA 的滑铁卢比赛开始前被一众大佬毒奶就感觉要凉~ 热身那天出题基本问题不大，T了七八次的那题评测姬背锅。主要是罚时爆炸，出题数还过得去吧。 今天不算打星57……省二吊车尾（居然吊住了）。三个人都要背锅。学长的锅主要是签到手滑WA两次，我的锅是模拟半天没时间修了，泽铭主要是键盘根本没碰着。 上个星期放弃复习大物打了三场训练赛，得到这个结果其实很气。选拔赛第三出线的，今天？？？我们在梦游吗？ 题解等官方题解出来再补。 这几天趁着好好反思一波。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"ACM游记","slug":"ACM游记","permalink":"/tags/ACM游记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"HDU1426 Sudoku Killer（DFS）","slug":"HDU1426-Sudoku-Killer（DFS）","date":"2019-04-02T12:25:50.000Z","updated":"2020-02-12T05:23:39.770Z","comments":true,"path":"2019/04/02/HDU1426-Sudoku-Killer（DFS）/","link":"","permalink":"/2019/04/02/HDU1426-Sudoku-Killer（DFS）/","excerpt":"和数独的不解之缘:D 初三的时候有段时间特别喜欢解数独，大概玩了一个星期就已经能把书里最难的数独题在十分钟以内破解。我觉得数独纯粹是一个推理+解方程的游戏，把所有能明确推理出来的空填上，剩下的只要设一个x就可以解出来，并没有什么奇技淫巧。 回到这道题，我还是有点害怕DFS。不怕不怕，多写写Yisin你一定可以的！吼= =","text":"和数独的不解之缘:D 初三的时候有段时间特别喜欢解数独，大概玩了一个星期就已经能把书里最难的数独题在十分钟以内破解。我觉得数独纯粹是一个推理+解方程的游戏，把所有能明确推理出来的空填上，剩下的只要设一个x就可以解出来，并没有什么奇技淫巧。 回到这道题，我还是有点害怕DFS。不怕不怕，多写写Yisin你一定可以的！吼= = HDU1426 Sudoku Killer（DFS）题目链接&lt;–点这里 自从2006年3月10日至11日的首届数独世界锦标赛以后，数独这项游戏越来越受到人们的喜爱和重视。 据说，在2008北京奥运会上，会将数独列为一个单独的项目进行比赛，冠军将有可能获得的一份巨大的奖品———HDU免费七日游外加lcy亲笔签名以及同hdu acm team合影留念的机会。 所以全球人民前仆后继，为了奖品日夜训练茶饭不思。当然也包括初学者linle，不过他太笨了又没有多少耐性，只能做做最最基本的数独题，不过他还是想得到那些奖品，你能帮帮他吗？你只要把答案告诉他就可以，不用教他是怎么做的。 数独游戏的规则是这样的：在一个9x9的方格中，你需要把数字1-9填写到空格当中，并且使方格的每一行和每一列中都包含1-9这九个数字。同时还要保证，空格中用粗线划分成9个3x3的方格也同时包含1-9这九个数字。比如有这样一个题，大家可以仔细观察一下，在这里面每行、每列，以及每个3x3的方格都包含1-9这九个数字。 Input 本题包含多组测试，每组之间由一个空行隔开。每组测试会给你一个 9*9 的矩阵，同一行相邻的两个元素用一个空格分开。其中1-9代表该位置的已经填好的数，问号（?）表示需要你填的数。 Output 对于每组测试，请输出它的解，同一行相邻的两个数用一个空格分开。两组解之间要一个空行。 对于每组测试数据保证它有且只有一个解。 Sample Input 7 1 2 ? 6 ? 3 5 8 ? 6 5 2 ? 7 1 ? 4 ? ? 8 5 1 3 6 7 2 9 2 4 ? 5 6 ? 3 7 5 ? 6 ? ? ? 2 4 1 1 ? 3 7 2 ? 9 ? 5 ? ? 1 9 7 5 4 8 6 6 ? 7 8 3 ? 5 1 9 8 5 9 ? 4 ? ? 2 3 Sample Output 7 1 2 4 6 9 3 5 8 3 6 5 2 8 7 1 9 4 4 9 8 5 1 3 6 7 2 9 2 4 1 5 6 8 3 7 5 7 6 3 9 8 2 4 1 1 8 3 7 2 4 9 6 5 2 3 1 9 7 5 4 8 6 6 4 7 8 3 2 5 1 9 8 5 9 6 4 1 7 2 3","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"/tags/搜索/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"HDU1584 蜘蛛牌（DFS）","slug":"HDU1584-蜘蛛牌（DFS）","date":"2019-04-02T10:54:57.000Z","updated":"2020-02-12T05:24:56.602Z","comments":true,"path":"2019/04/02/HDU1584-蜘蛛牌（DFS）/","link":"","permalink":"/2019/04/02/HDU1584-蜘蛛牌（DFS）/","excerpt":"听说此题做不出深搜就还没到功夫QAQ 说的可能就是我 这一题乍一看是dp（可以用dp做，但是是数位dp……),还是好好想想DFS怎么做叭，嘤~","text":"听说此题做不出深搜就还没到功夫QAQ 说的可能就是我 这一题乍一看是dp（可以用dp做，但是是数位dp……),还是好好想想DFS怎么做叭，嘤~ HDU1584 蜘蛛牌（DFS）题目链接&lt;–点这里 蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。 Input 第一个输入数据是T，表示数据的组数。 每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。 Output 对应每组数据输出最小移动距离。 Sample Input 1 1 2 3 4 5 6 7 8 9 10 Sample Output 9 我觉得这位巨巨讲的很好，可戳 如果我来讲的话，这道题的关键点和所有DFS一样，就是有个递归过程。那么我们脑动模拟蜘蛛纸牌过程，可以发现这个递归关键点在于要不要先把第i张牌移动到比它大1的数字下方。 需要注意的是，比它大1的数字不一定在一开始的位置，所以需要用一个vis[]数组标记每张牌是否被移动。因为每张牌只能放在比它大1的牌下方，所以如果某张牌被标记为移动，只需要从这张牌往后遍历第一张没有被移动的牌，就是一开始那张牌现在所在的位置。 整个dfs过程我们需要两个变量，num代表已经排好的牌数量，sum代表当前距离和。优化剪枝的地方在于，如果sum&gt;ans(之前搜索到的最小完整sum值)，可以直接return，因为这一定不是最优解。边界条件就是当num==9时，说明我们移动了9张牌，整个蜘蛛纸牌已经有序，需要return，把sum值赋给ans（因为没有被剪枝，所以此时sum一定 &lt; ans,为当前搜索到的最优解。 代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; int a[15],vis[15],ans; void dfs(int num,int sum) { if(sum&gt;ans) return ; if(num==9) { ans=sum; return; } else { for(int i=1;i&lt;=10;i++) { if(!vis[i]) { vis[i]=1; for(int j=i+1;j&lt;=10;j++) { if(!vis[j]) { dfs(num+1,sum+abs(a[i]-a[j])); break; } } vis[i]=0; //回溯，dfs的关键 } } } } int main() { int t; cin&gt;&gt;t; while(t--) { for(int i=1;i&lt;=10;i++) { int x; cin&gt;&gt;x; a[x]=i; } ans=1000000; dfs(0,0); cout&lt;&lt;ans&lt;&lt;endl; } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"/tags/搜索/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"密码学之数论基础","slug":"密码学之数论基础","date":"2019-04-01T05:03:06.000Z","updated":"2020-02-12T05:26:59.955Z","comments":true,"path":"2019/04/01/密码学之数论基础/","link":"","permalink":"/2019/04/01/密码学之数论基础/","excerpt":"我爱数学！ 数论是计算机领域的基础，包括ACM、CTF都会用到。我的数学底子一般，曾经参加过数竞培训，但是已经荒废了很久。应用能力比证明能力强。但是我想做踏踏实实走攻数论这条路的人，因为我坚信数学的威力是无穷的。毕竟经济基础决定上层建筑。（大雾）","text":"我爱数学！ 数论是计算机领域的基础，包括ACM、CTF都会用到。我的数学底子一般，曾经参加过数竞培训，但是已经荒废了很久。应用能力比证明能力强。但是我想做踏踏实实走攻数论这条路的人，因为我坚信数学的威力是无穷的。毕竟经济基础决定上层建筑。（大雾） 密码学之数论基础以下内容部分引自境外之王’s blog，感谢~ 素数素数，又叫质数，定义是除了1和它本身以外不再有其他的因数。 整数p&gt;1是素数当且仅当它只有因子+(-)1和+(-)p。 任意整数a&gt;1都可以唯一地因子分解为： 其中p1,p2,…,pt均是素数，p1&lt;p2&lt;…&lt;pt,且所有的ai都是正整数。这就是算术基本定理。 设P是所有素数的集合，则任意正整数a可唯一地表示为： 上式右边是所有素数之积。对某一整数a，其大多数指数ap为0. 两数相乘即是指数对应相加。设，定义k=ab。我们知道整数k可以表示为素数方幂的乘积：。可以推出对于所有的p属于P，有kp=ap+bp成立。 我们通过这个定义，可以写如下程序判断一个数是不是质数 bool prime(int x)//判断x是不是质数，是返回true，不是返回false { if(x &lt;= 1) return false; for(int i = 2; i &lt; x; i ++){ if(x % i == 0) return false; } return true; } 这个程序的时间复杂度是O(n)，有没有更快的方法，当然 看这个 bool prime(int x)//判断x是不是质数，是返回true，不是返回false { if(x &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(x + 0.5); i ++)//0.5是防止根号的精度误差 { if(x % i == 0) return false; } return true; } //另一种方法，不需要根号 bool prime(int x)//判断x是不是质数，是返回true，不是返回false { if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++)//用乘法避免根号的精度误差 { if(x % i == 0) return false; } return true; } //根据题目不同，如果i*i会爆int，记得开longlong 这个复杂度是O(√n),速度快多了 根据题目不同，有可能你需要先预处理出1~N这N个数是否是素数 如果用刚刚的方法，复杂度就是O(n√n) #include&lt;cstdio&gt; const int N = 100000 + 5; bool prime[N]; bool is_prime(int x) { if(x &lt;= 1) return false; for(int i = 2; i * i &lt;= x; i ++) { if(x % i == 0) return false; } return true; } void init() { for(int i = 0; i &lt; N; i ++) { prime[i] = is_prime(i); } } int main() { init(); } 如果n大一点，就太慢了 介绍一种新方法，埃筛 埃筛————–埃拉托斯特尼筛法，或者叫埃氏筛法 原理：如果找到一个质数，那么这个质数的倍数都不是质数 比如2是质数，那么4,6,8,10,12…都不是质数 然后看3是质数，那么6,9,12,15,18,21…都不是质数 然后看4，4已经被2标记为合数了，所以跳过 然后看5……这样一直筛下去 #include&lt;cstdio&gt; const int N = 100000 + 5; bool prime[N]; void init() { for(int i = 2; i &lt; N; i ++) prime[i] = true;//先全部初始化为质数 for(int i = 2; i &lt; N; i ++) { if(prime[i])//如果i是质数 { for(int j = 2*i; j &lt; N; j += i)//从i的两倍开始的所有倍数 { prime[j] = false; } } } } int main() { init(); } 因为一些数字，比如6既被2的for循环经过又被3的for循环经过，所以复杂度不是O(n) 这个复杂度经过专业人士检验，复杂度O(nloglogn)（学过高数的小朋友可以自己证明≖‿≖✧当然也可以去百度） 知道原理后，我们再稍微优化一下就更快了 #include&lt;cstdio&gt; const int N = 100000 + 5; bool prime[N]; void init() { for(int i = 2; i &lt; N; i ++) prime[i] = true; for(int i = 2; i*i &lt; N; i ++)//判断改成i*i&lt;N { if(prime[i]) { for(int j = i*i; j &lt; N; j += i)//从i*i开始就可以了 { prime[j] = false; } } } } int main() { init(); } 快速幂a的b次方怎么求 pow（a, b）是数学头文件math.h里面有的函数 可是它返回值是double类型，数据有精度误差 那就自己写for循环咯 LL pow(LL a, LL b)//a的b次方 { LL ret = 1; for(LL i = 1; i &lt;= b; i ++) { ret *= a; } return ret; } 完美 可是题目是b的范围是1 &lt;= b &lt;= 1e9 超时，妥妥的。。。 看个例子 比如计算 2*2*2*2*2*2*2*2*2*2*2 可以这样算 原式=4*4*4*4*4*2 =8*8*4*2 =16*4*2 你看，相同的可以先合并，减少计算步骤 如果题目说数据很大，还需要求余，那么代码就可以这么写 LL pow_mod(LL a, LL b)//a的b次方 { if(b == 0) return 1; LL ret = pow_mod(a, b/2); ret = ret * ret % MOD; if(b % 2 == 1) ret = ret * a % MOD; return ret; } 这是递归写法 然后还有递推写法 LL pow_mod(LL a, LL b)//a的b次方 { LL ret = 1; while(b != 0) { if(b % 2 == 1) { ret = (ret * a) % MOD ; } a = (a * a ) % MOD ; b /= 2; } return ret; } 对于位运算熟的小盆友，还可以写成位运算形式，速度又快，又好理解，在加一个求余p，代码如下 LL pow_mod(LL a, LL b, LL p)//a的b次方求余p { LL ret = 1; while(b) { if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; } return ret; } 有了快速幂，于是，快速乘诞生了 LL mul(LL a, LL b, LL p)//快速乘，计算a*b%p { LL ret = 0; while(b) { if(b &amp; 1) ret = (ret + a) % p; a = (a + a) % p; b &gt;&gt;= 1; } return ret; } 最大公约数gcd和最小公倍数lcmgcd(a, b)，就是求a和b的最大公约数 lcm(a, b)，就是求a和b的最小公倍数 然后有个公式 ab = gcd lcm ( gcd就是gcd(a, b)， ( •̀∀•́ ) 简写你懂吗) 解释（不想看就跳过）{ 首先，求一个gcd，然后。。。 a / gcd 和 b / gcd 这两个数互质了，也就是 gcd( a / gcd ，b / gcd ) = 1，然后。。。 lcm = gcd (a / gcd) (b / gcd) lcm = (a * b) / gcd 所以。。ab = gcd lcm } 所以要求lcm，先求gcd 辣么，问题来了，gcd怎么求 辗转相除法 while循环 LL gcd(LL a, LL b) { LL t; while(b) { t = b; b = a % b; a = t; } return a; } 还有一个递归写法 LL gcd(LL a, LL b) { if(b == 0) return a; else return gcd(b, a%b); } LL gcd(LL a, LL b) { return b ? gcd(b, a%b) : a; } //两种都可以 辣么，lcm = a * b / gcd (注意，这样写法有可能会错，因为a * b可能因为太大 超出int 或者 超出 longlong) 所以推荐写成 ： lcm = a / gcd * b 然后几个公式自己证明一下 gcd(ka, kb) = k * gcd(a, b) lcm(ka, kb) = k * lcm(a, b) 上次做题碰到这个公式 lcm(S/a, S/b) = S/gcd(a, b) S = 9，a = 4，b = 6，小数不会lcm，只好保留分数形式去通分约分。 扩展欧几里德算法度娘百科说： 首先， ax+by = gcd(a, b) 这个公式肯定有解 （( •̀∀•́ )她说根据数论中的相关定理可以证明，反正我信了） 所以 ax+by = gcd(a, b) * k 也肯定有解 （废话，把x和y乘k倍就好了） 所以，这个公式我们写作ax+by = d，(gcd(a, b) | d) gcd(a, b) | d，表示d能整除gcd，这个符号在数学上经常见 那么已知 a，b 求 一组解 x，y 满足 ax+by = gcd(a, b) 这个公式 #include&lt;cstdio&gt; typedef long long LL; void extend_Eulid(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d) { if (!b) {d = a, x = 1, y = 0;} else { extend_Eulid(b, a % b, y, x, d); y -= x * (a / b); } } int main() { LL a, b, d, x, y; while(~scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b)) { extend_Eulid(a, b, x, y, d); printf(&quot;%lld*a + %lld*b = %lld\\n&quot;, x, y, d); } } 有些人喜欢极度简化，这是病，得治(,,• ₃ •,,) void ex_gcd(LL a, LL b, LL &amp;d, LL &amp;x, LL &amp;y) { if(!b){d = a; x = 1; y = 0;} else{ex_gcd(b, a%b, d, y, x); y -= x*(a/b);} } 数论四大定理（提示：以后出现（mod p）就表示这个公式是在求余p的条件下成立） 威尔逊定理当且仅当p为素数时：( p -1 )! ≡ -1 ( mod p ) 或者这么写( p -1 )! ≡ p-1 ( mod p ) 或者说 若p为质数，则p能被(p-1)!+1整除 在初等数论中 这是威尔逊给出了判定一个自然数是否为 素数 的 充分必要条件 但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。(´・ω・`)（威尔逊表示很伤心） 欧拉定理欧拉定理，也称费马-欧拉定理 若n,a为正整数，且n,a互质，即gcd(a,n) = 1，则 a^φ(n) ≡ 1 (mod n) φ(n) 是欧拉函数 欧拉函数是求小于等于n的数中与n互质的数的数目 (o&gt;▽&lt;)太长看不懂？我来帮你断句 欧拉函数是求 （小于n的数 ）中 （与n互质的数 ）的数目 或者说 欧拉函数是求 1到n-1 中 与n互质的数 的数目 如果n是质数 那么1到n-1所有数都是与n互质的， 所以φ(n) = n-1 如果n是合数。。。自己算吧 例如φ(8)=4，因为1,3,5,7均和8互质 顺便一提，这是欧拉定理 φ(n)是欧拉函数 还有一个欧拉公式 eix = cosx + isinx 把x用π带进去，变成 eiπ= -1 大部分人写成 eiπ + 1 = 0 这是一个令万人膜拜的伟大公式 一定要分清 欧拉定理，欧拉函数和欧拉公式这3个东西，要不然你就百度不到你想要的东西了 孙子定理（中国剩余定理）孙子定理，又称中国剩余定理。 公元前后的《孙子算经》中有“物不知数”问题：“今有物不知其数，三三数之余二 ，五五数之余三 ，七七数之余二，问物几何？”答为“23”。 就是说，有一个东西不知道有多少个，但是它求余3等于2，求余5等于3，求余7等于2，问这个东西有多少个？”答为“23”。 用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组： 中国剩余定理说明：假设整数m1,m2, … ,mn两两互质，则对任意的整数：a1,a2, … ,an，方程组 (S)有解 剩余类定义比n小的非负整数集合为Zn: Zn={0,1,….,(n-1)} 这个集合被成为剩余类集，或模n的剩余类。更准确地说，Zn中每一个整数都代表一个剩余类，我们可以将模n的剩余类表示为[0],[1],[2],…,[n-1],其中 [r]={a:a是一个整数，a与r模n同余} 在剩余类的所有整数中，我们通常用最小非负整数来代表这个剩余类。寻找与k是模n同余的最小非负整数的过程，称为模n的k约化。 比如：当k=8，n=4时，寻找8 mod4同余的最小非负整数为0，当k=7，n=4时，寻找7 mod4 同余的最小非负整数为3. 笛卡尔积笛卡尔积又叫笛卡尔乘积，是一个叫笛卡尔的人提出来的。简单的说就是两个集合相乘的结果。 举个例子： 集合A={a1,a2,a3} 集合B={b1,b2} 他们的笛卡尔积是 A*B={(a1,b1),(a1,b2),(a2,b1),(a2,b2),(a3,b1),(a3,b2)} 即任意两个元素结合在一起 CRT中国剩余定理(CRT)是数论中最有用的定理之一。CRT说明某一范围内的整数可通过它的一组剩余类来重构，这组剩余类数是对该整数用一组两两互素的整数取模得到的。CRT可有几种不同的表示形式，这里我们给出其中一种最有用的表示形式： 其中mi是两两互素的，即对1&lt;=i,j&lt;=k, i!=j 有gcd(mi,mj)=1。我们可将ZM中的任一整数对应一个k元组，该k元组的元素均在Zmi中，这种对应关系即为： 其中A属于ZM，对于1&lt;=i&lt;=k, ai属于Zmi，且ai=A mod mi。 CRT 说明下列两个断言成立： (1)上面的映射是ZM到笛卡尔积Zm1Zm2….*Zmk的一一对应(称为双射)，也就是说，对任何A，0&lt;=A&lt;=M,有唯一的k元组(a1,a2,…,ak)与之对应，其中0&lt;=ai&lt;mi,并且对任何这样的k元组(a1,a2,…,ak),ZM中有唯一的A与之对应。 (2)ZM中元素上的运算可等价于对应的k元组上的运算，即在笛卡尔积的每一个分量上独立地执行运算。 中国剩余定理的用途之一是，它给出了一种方法，使得模M的大数运算转化到更小的数上来进行运算，当M为150位或150位以上时，这种方法非常有效。 费马小定理假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。 或者说，若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。 你看你看你看o(*≧▽≦)ツ，是不是和欧拉定理很像 因为欧拉定理是费马小定理的推广，所以欧拉定理也叫费马-欧拉定理 顺便一提，费马大定理 费马大定理，又被称为“费马最后的定理”，由法国数学家费马提出。 它断言当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^n 没有正整数解。 被提出后，经历多人猜想辩证，历经三百多年的历史，最终在1995年被英国数学家安德鲁·怀尔斯证明。 离散对数大部分摘录于《密码编码学与网络安全》 离散对数是包括Diffie-Hellman密钥交换和数字签名算法(DSA)在内的许多公钥算法的基础。 模n的整数幂 本原根 模算术对数 未完待续QAQ","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"数论","slug":"数论","permalink":"/tags/数论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"图论入门","slug":"图论入门","date":"2019-03-29T11:40:52.000Z","updated":"2020-02-12T05:28:38.928Z","comments":true,"path":"2019/03/29/图论入门/","link":"","permalink":"/2019/03/29/图论入门/","excerpt":"从今儿起，我就正儿八经地开始更新学习算法的一些心得惹，图论主要参考的是张新华老师的《算法竞赛宝典》。到时候离散数学学到这里以后，我再进行补充吧。现在只能拿着张老师的书照本宣科。 以下绝对是新手友好系列。因为我自己就是一个菜鸡QAQ，走到哪里都是全队最菜。我检讨。 入门内容包括图的基本概念、图的存储结构（邻接数组、邻接表）、深度优先法、广度优先法。","text":"从今儿起，我就正儿八经地开始更新学习算法的一些心得惹，图论主要参考的是张新华老师的《算法竞赛宝典》。到时候离散数学学到这里以后，我再进行补充吧。现在只能拿着张老师的书照本宣科。 以下绝对是新手友好系列。因为我自己就是一个菜鸡QAQ，走到哪里都是全队最菜。我检讨。 入门内容包括图的基本概念、图的存储结构（邻接数组、邻接表）、深度优先法、广度优先法。 图论入门图的基本概念图是一种非线性结构，由顶点的有穷非空集合和顶点之间边的集合组成。数据元素之间是多对多的关系，即网状结构关系。 图可以分为有向图和无向图两类。无向图：任意两个顶点之间的边都是无向边（简而言之就是没有方向的边）；有向图：任意两个顶点之间的边都是有向边（简而言之就是有方向的边）。 需要注意的是，无论是有向图还是无向图，都需要遵循两点限制： 图形不允许自身循环（每个顶点不能构成自环） 任意两顶点之间的边数不能超过1，即边不能重复 以下是图论中一些基本名词概念解释： 完全图：无向图的任意两顶点之间都存在边（有向图为任意两顶点之间都存在双向边） 路径：在图中由一顶点A到另一顶点B经过的所有边。路径长度为经过的边数。 简单路径：路径上的各顶点（除起点、终点）均不互相重复。 回路：路径上的第一个顶点与最后一个顶点重合的简单路径。下图回路有(A,B,C,D,E,A)等等。 连通顶点：无向图中两个存在一条路径的顶点。 连通图：无向图中任意两个顶点皆连通。 强连通顶点：有向图中两个存在双向边的顶点。 强连通图形：有向图中任意两个顶点皆存在双向边。 度：有向图中，内分支度是指其他顶点前往此顶点的边数，外分支度是指此顶点前往其他顶点的边数。 权：有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。 图的存储结构邻接数组图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 无向图我们可以设置两个数组，顶点数组为vertex[4]={v0,v1,v2,v3}，边数组arc[4][4]为上图右边这样的一个矩阵。对于矩阵的主对角线的值，即arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]，全为0是因为不存在顶点的边。 有向图我们再来看一个有向图样例，如下图所示的左边。顶点数组为vertex[4]={v0,v1,v2,v3}，弧数组arc[4][4]为下图右边这样的一个矩阵。主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称，比如由v1到v0有弧，得到arc[1][0]=1，而v到v没有弧，因此arc[0][1]=0。邻接表由于存在n个顶点的图需要n*n个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费。这时，可以考虑使用邻接表表示法来存储图中的数据。 邻接表由表头节点和表节点两部分组成，图中每个顶点均对应一个存储在数组中的表头节点。如果这个表头节点所对应的顶点存在邻接节点，则把邻接节点依次存放于表头节点所指向的单向链表中。 无向图 从上图中我们知道，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。例如：v1顶点与v0、v2互为邻接点，则在v1的边表中，adjvex分别为v0的0和v2的2。 对于无向图来说，使用邻接表进行存储也会出现数据冗余的现象。例如上图中，顶点V0所指向的链表中存在一个指向顶点V3的同事，顶点V3所指向的链表中也会存在一个指向V0的顶点。 有向图 若是有向图，邻接表结构是类似的，但要注意的是有向图由于有方向的。因此，有向图的邻接表分为出边表和入边表（又称逆邻接表），出边表的表节点存放的是从表头节点出发的有向边所指的尾节点；入边表的表节点存放的则是指向表头节点的某个顶点，如下图所示。 带权图 对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可，如下图所示。 深度优先法广度优先法留坑，待填……","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"图论","slug":"图论","permalink":"/tags/图论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"蓝桥杯总结","slug":"蓝桥杯总结","date":"2019-03-28T10:42:34.000Z","updated":"2020-02-12T05:19:22.951Z","comments":true,"path":"2019/03/28/蓝桥杯总结/","link":"","permalink":"/2019/03/28/蓝桥杯总结/","excerpt":"年轻人要多刷题，少水群，才能进Final。 by Kuangbin 其实如果可以的话，我特别不想面对这个结果。省二都排到了中游的位置，这已经不单纯是运气背的问题了……","text":"年轻人要多刷题，少水群，才能进Final。 by Kuangbin 其实如果可以的话，我特别不想面对这个结果。省二都排到了中游的位置，这已经不单纯是运气背的问题了…… 蓝桥杯总结考完出了综合楼，和紫闻、泽铭一对答案，我就知道我要凉。特别是中位数那题他们的答案是42，我愣了，我写的是三位数——忽然惊醒——题目要求中位数的中位数，我求成了中位数的和。 以及后来看到群里填空最后一空他们是18位，而我大概只有16位，但是我确信我的e都已经求正确了，只不过最后的快速幂写不出来，用的方法大概错了。而大家都会的迷宫bfs，我不会。考前就一直在祈祷，不要出搜索题，遇搜索必死。 大题第二题以后我基本就是争取过几个点，最后一题连题目都没读懂。而且简单的二叉树我好像忘记考虑最大值为负的情况了。 大概是迎面一桶冷水的感觉。虽然不知道CCCC选拔赛的时候自己明明已经好久没碰过算法却出乎意料地稳，但是蓝桥杯展现出来的，才是我真实的水平吧。连我自己都不敢承认的失败。 不想说失败是成功之母。如果可以，谁不想顺顺利利的，谁愿意历经无数次失败还在憧憬成功的曙光？但是失败了，面对失败，找到失败的原因，这个的确是一个loser需要做的事情。 这次出现失误的原因总结： 基础不扎实。像dfs、bfs、dp、快速幂等基础题本来寒假就应该巩固好，但是我自己寒假偷懒只学了STL，导致一大片知识还有盲区。以及离开板子就会丧失好多题目的解题。 开学以来对算法的训练非常少。cf打的次数屈指可数。虽说cf也不是评判的唯一标准，但是题目写的少是事实。 赛场上读题大意，遇到不返回实时结果的情况手足无措。 备战六月份的女生赛，我觉得自己这段时间是该好好收收心，多刷题，少水群。至少这一个月要快速把搜索、dp拿下，剩下的时间看看数论相关知识。还有英语能力的提高。 我本可以忍受黑暗，如果没有见过光明。寒假前我有机会放弃竞赛，但是遇到了wls一干人后，我选定了继续下去的路。我希望，蓝桥杯能留给我一个很深刻的教训，也希望明年此时，我不会再次抱憾归来。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"天梯赛选拔Day1","slug":"天梯赛选拔Day1","date":"2019-03-18T05:15:14.000Z","updated":"2020-02-12T06:18:41.049Z","comments":true,"path":"2019/03/18/天梯赛选拔Day1/","link":"","permalink":"/2019/03/18/天梯赛选拔Day1/","excerpt":"心之所向，素履以往；生如逆旅，一苇以航 3月15日接到16、17两天连续选拔赛的消息的时候整个人是慌的，因为从开学到现在都没有怎么写过代码。那晚连散人直播《最强大~脑》都不看了，在宿舍里焦躁地徘徊，一直跟小姐姐说我不行的。最后熬夜又刷了PAT上几道题试图平复心情。 3月16日上午我整理了《All Things About STL》这篇博文，来复习STL基础的操作类型。时间有限，也没能好好看完。 和学姐一起走到科技楼的时候，我一遍又一遍想不要害怕，得之我幸，失之我命，水平决定一切。但比赛开始的时候我还是手忙脚乱，不断出错，而且浏览器似乎有些奇奇怪怪的问题，动不动就崩。等我写完第一题的时候，已经排到了三四十名的位置。换在平时训练赛，这是完全不可能的事情。好在PAT机制下不算错误率和时间，所以一开始的失利并没有太影响到我。之后每写完一题就前进一些，到第八题写完，已经回到第五差不多的位置了。 最后的成绩： 接下来带来题解，前十题我会用自己的方法（+大佬做法）讲，后五题我用大佬做法讲（+教泥萌怎么蒙）。","text":"心之所向，素履以往；生如逆旅，一苇以航 3月15日接到16、17两天连续选拔赛的消息的时候整个人是慌的，因为从开学到现在都没有怎么写过代码。那晚连散人直播《最强大~脑》都不看了，在宿舍里焦躁地徘徊，一直跟小姐姐说我不行的。最后熬夜又刷了PAT上几道题试图平复心情。 3月16日上午我整理了《All Things About STL》这篇博文，来复习STL基础的操作类型。时间有限，也没能好好看完。 和学姐一起走到科技楼的时候，我一遍又一遍想不要害怕，得之我幸，失之我命，水平决定一切。但比赛开始的时候我还是手忙脚乱，不断出错，而且浏览器似乎有些奇奇怪怪的问题，动不动就崩。等我写完第一题的时候，已经排到了三四十名的位置。换在平时训练赛，这是完全不可能的事情。好在PAT机制下不算错误率和时间，所以一开始的失利并没有太影响到我。之后每写完一题就前进一些，到第八题写完，已经回到第五差不多的位置了。 最后的成绩： 接下来带来题解，前十题我会用自己的方法（+大佬做法）讲，后五题我用大佬做法讲（+教泥萌怎么蒙）。 天梯赛选拔Day17-1 到底有多二 （15 分)一个整数“犯二的程度”定义为该数字中包含2的个数与其位数的比值。如果这个数是负数，则程度增加0.5倍；如果还是个偶数，则再增加1倍。例如数字-13142223336是个11位数，其中有3个2，并且是负数，也是偶数，则它的犯二程度计算为：3/11×1.5×2×100%，约为81.82%。本题就请你计算一个给定整数到底有多二。 输入格式： 输入第一行给出一个不超过50位的整数N。 输出格式： 在一行中输出N犯二的程度，保留小数点后两位。 输入样例： -13142223336 输出样例： 81.82% 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 先阐明一个小学数学老师经常强调的点：x增加0.5倍 == x 1.5；x增加1倍 == x 2（well，这里应该也不会有人错）。 单纯找2的话只需要把数据当成字符串读入，寻找2的个数；由于题目同时要求判断是否负数和偶数，还需要对字符串首位和末位进行判断。 窝的代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { //ios::sync_with_stdio(false); string s; cin&gt;&gt;s; int ans=0,flag1=0,flag2=0; int n=s.size(); for(int i=0;i&lt;s.size();i++) { if(s[i]==&#39;-&#39;) { flag1=1; n--; continue; } if(s[i]==&#39;2&#39;) ans++; if(i==s.size()-1&amp;&amp;(s[i]-&#39;0&#39;)%2==0) flag2=1; } //cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;endl; double m=ans*100.0/n; //cout&lt;&lt;m&lt;&lt;endl; if(flag1==1) m*=1.5; if(flag2==1) m*=2; printf(&quot;%.2f&quot;,m); cout&lt;&lt;&quot;%&quot;&lt;&lt;endl; return 0; } 有一点需要额外注意，如果取消流同步（ios::sync_with_stdio(false)）了以后输出千万不能cout和printf混用，不然……答案全部错误。刚开始吓傻窝了，还好从前遇到过，还请教过学长萌QWQ 7-2 大笨钟 （10 分)微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。 下面就请你写个程序，根据当前时间替大笨钟敲钟。 输入格式： 输入第一行按照hh:mm的格式给出当前时间。其中hh是小时，在00到23之间；mm是分钟，在00到59之间。 输出格式： 根据当前时间替大笨钟敲钟，即在一行中输出相应数量个Dang。如果不是敲钟期，则输出： Only hh:mm. Too early to Dang. 其中hh:mm是输入的时间。 输入样例1： 19:05 输出样例1： DangDangDangDangDangDangDangDang 输入样例2： 07:05 输出样例2： Only 07:05. Too early to Dang. 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 水题~分类讨论就行 代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); string s; cin&gt;&gt;s; int h=(s[0]-&#39;0&#39;)*10+(s[1]-&#39;0&#39;); int m=(s[3]-&#39;0&#39;)*10+(s[4]-&#39;0&#39;); if(h&lt;12) cout&lt;&lt;&quot;Only &quot;&lt;&lt;s&lt;&lt;&quot;. Too early to Dang.&quot;&lt;&lt;endl; else if(h==12&amp;&amp;m==0) cout&lt;&lt;&quot;Only &quot;&lt;&lt;s&lt;&lt;&quot;. Too early to Dang.&quot;&lt;&lt;endl; else { if(m==0) { for(int i=0;i&lt;h-12;i++) cout&lt;&lt;&quot;Dang&quot;; } else { for(int i=0;i&lt;=h-12;i++) cout&lt;&lt;&quot;Dang&quot;; } } return 0; } 7-3 谁先倒 （15 分)划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。 输入格式： 输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（≤100），随后N行，每行给出一轮划拳的记录，格式为： 甲喊 甲划 乙喊 乙划 其中喊是喊出的数字，划是划出的数字，均为不超过100的正整数（两只手一起划）。 输出格式： 在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。 输入样例： 1 1 6 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 15 1 1 16 输出样例： A 1 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 我先提供一份最开始只得了4分的错误代码，泥萌找找哪里有问题 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int a1[105],a2[105],b1[105],b2[105]; int main() { ios::sync_with_stdio(false); int a,b,n,ans1=0,ans2=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; for(int i=0;i&lt;n;i++) { if(ans1==a||ans2==b) break; cin&gt;&gt;a1[i]&gt;&gt;a2[i]&gt;&gt;b1[i]&gt;&gt;b2[i]; int m=a1[i]+b1[i]; if(a2[i]==m) ans1++; if(b2[i]==m) ans2++; } if(ans1==a) cout&lt;&lt;&#39;A&#39;&lt;&lt;endl&lt;&lt;ans2&lt;&lt;endl; else cout&lt;&lt;&#39;B&#39;&lt;&lt;endl&lt;&lt;ans1&lt;&lt;endl; return 0; } 相信（jia she）泥萌已经发现了，理解题意的重要性。 问题出在下面这几行 if(a2[i]==m) ans1++; if(b2[i]==m) ans2++; 而题目中说：谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮 也就是说，不仅需要满足一人输，还需要满足另一个人嬴。 AC代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int a1[105],a2[105],b1[105],b2[105]; int main() { ios::sync_with_stdio(false); int a,b,n,ans1=0,ans2=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a1[i]&gt;&gt;a2[i]&gt;&gt;b1[i]&gt;&gt;b2[i]; } for(int i=0;i&lt;n;i++) { if(ans1&gt;a||ans2&gt;b) break; int m=a1[i]+b1[i]; if(a2[i]==m&amp;&amp;b2[i]!=m) ans1++; if(b2[i]==m&amp;&amp;a2[i]!=m) ans2++; } if(ans1&gt;a) cout&lt;&lt;&#39;A&#39;&lt;&lt;endl&lt;&lt;ans2&lt;&lt;endl; else cout&lt;&lt;&#39;B&#39;&lt;&lt;endl&lt;&lt;ans1&lt;&lt;endl; return 0; } 7-4 帅到没朋友 （20 分)当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。 输入格式： 输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。 注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。 输出格式： 按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。 注意：同一个人可以被查询多次，但只输出一次。 输入样例1： 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 8 55555 44444 10000 88888 22222 11111 23333 88888 输出样例1： 10000 88888 23333 输入样例2： 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 4 55555 44444 22222 11111 输出样例2： No one is handsome 时间限制: 250 ms 内存限制: 64 MB 代码长度限制: 16 KB 照例先放错误代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); map&lt;string,int&gt;mp,mp2; queue&lt;string&gt;q; int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; while(m--) { string s; cin&gt;&gt;s; mp[s]++; } } int p; cin&gt;&gt;p; while(p--) { string s; cin&gt;&gt;s; if(mp2[s]==0) { if(mp[s]==0) q.push(s); } mp2[s]++; } if(q.empty()) cout&lt;&lt;&quot;No one is handsome&quot;&lt;&lt;endl; else { while(!q.empty()) { if(q.size()==1) cout&lt;&lt;q.front()&lt;&lt;endl; else cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;; q.pop(); } } return 0; } 又是没好好读题的锅~ 没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。也就是说，k=1的时候和没有k的时候没区别啊。wsl~ 这道题我用了queue+map（其实可以不用queue，直接在线查询就行）。map的思路就是：当k&gt;1时，把后面所有编号纳入map，之后查询的时候只要看看map的值是否为0就行。还要注意：同一个人可以被查询多次，但只输出一次。所以要再用一个map记录是否已经被查询过。当然这道题的编号并不大，用数组也ok，就是注意输出要把前导0补全。 AC代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); map&lt;string,int&gt;mp,mp2; queue&lt;string&gt;q; int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { string s; cin&gt;&gt;s; if(m&gt;1) mp[s]++; } } int p; cin&gt;&gt;p; while(p--) { string s; cin&gt;&gt;s; if(mp2[s]==0) { if(mp[s]==0) q.push(s); } mp2[s]++; } if(q.empty()) cout&lt;&lt;&quot;No one is handsome&quot;&lt;&lt;endl; else { while(!q.empty()) { if(q.size()==1) cout&lt;&lt;q.front()&lt;&lt;endl; else cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;; q.pop(); } } return 0; } 7-5 重要的话说三遍 （5 分)7-6 奇偶分家 （10 分)//5、6两道zz题窝就直接跳了= = 7-7 输出GPLT （20 分)给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按GPLTGPLT….这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按GPLT的顺序打印，直到所有字符都被输出。 输入格式： 输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。 输出格式： 在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例： pcTclnGloRgLrtLhgljkLhGFauPewSKgt 输出样例： GPLTGPLTGLTGLGLL 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB 这道题纯暴力。本来想看看网上有没有什么大佬的巧妙解法，发现只能模拟。这道题题意可以转换到分别统计GPLT个数，然后依次输出。 AC代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int main() { ios::sync_with_stdio(false); string s; cin&gt;&gt;s; int ans1=0,ans2=0,ans3=0,ans4=0; for(int i=0;i&lt;s.size();i++) { if(s[i]==&#39;G&#39;||s[i]==&#39;g&#39;) ans1++; if(s[i]==&#39;P&#39;||s[i]==&#39;p&#39;) ans2++; if(s[i]==&#39;L&#39;||s[i]==&#39;l&#39;) ans3++; if(s[i]==&#39;T&#39;||s[i]==&#39;t&#39;) ans4++; } int m=max(max(ans1,ans2),max(ans3,ans4)); while(m--) { if(ans1&gt;0) { cout&lt;&lt;&#39;G&#39;; ans1--; } if(ans2&gt;0) { cout&lt;&lt;&#39;P&#39;; ans2--; } if(ans3&gt;0) { cout&lt;&lt;&#39;L&#39;; ans3--; } if(ans4&gt;0) { cout&lt;&lt;&#39;T&#39;; ans4--; } } return 0; } 7-8 后天 （5 分)//又是水题~跳鸭 7-9 抢红包 （25 分)没有人没抢过红包吧…… 这里给出N个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。 输入格式： 输入第一行给出一个正整数N（≤10^​4），即参与发红包和抢红包的总人数，则这些人从1到N编号。随后N行，第i行给出编号为i的人发红包的记录，格式如下： K N1 P​1 ⋯NK P​K 其中K（0≤K≤20）是发出去的红包个数，Ni是抢到红包的人的编号，Pi（&gt;0）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。 输出格式： 按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。 输入样例： 10 3 2 22 10 58 8 125 5 1 345 3 211 5 233 7 13 8 101 1 7 8800 2 1 1000 2 1000 2 4 250 10 320 6 5 11 9 22 8 33 7 44 10 55 4 2 1 3 8800 2 1 23 2 123 1 8 250 4 2 121 4 516 7 112 9 10 输出样例： 1 11.63 2 3.63 8 3.63 3 2.11 7 1.69 6 -1.67 9 -2.18 10 -3.26 5 -3.26 4 -12.32 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 用个结构体排序就好惹，不多说，直接上代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; struct p { int num,money,n; }s[100005]; bool cmp(p a,p b) { if(a.money==b.money) { if(a.n==b.n) return a.num&lt;b.num; return a.n&gt;b.n; } return a.money&gt;b.money; } int main() { //ios::sync_with_stdio(false); int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { s[i].num=i; int m,sum=0; cin&gt;&gt;m; while(m--) { int c,d; cin&gt;&gt;c&gt;&gt;d; s[c].n++; s[c].money+=d; sum+=d; } s[i].money-=sum; } sort(s+1,s+n+1,cmp); for(int i=1;i&lt;=n;i++) { cout&lt;&lt;s[i].num&lt;&lt;&quot; &quot;; printf(&quot;%.2f\\n&quot;,s[i].money/100.0); } return 0; } 7-10 排座位 （25 分)布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。 输入格式： 输入第一行给出3个正整数：N（≤100），即前来参宴的宾客总人数，则这些人从1到N编号；M为已知两两宾客之间的关系数；K为查询的条数。随后M行，每行给出一对宾客之间的关系，格式为：宾客1 宾客2 关系，其中关系为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后K行，每行给出一对需要查询的宾客编号。 这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。 输出格式： 对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出No problem；如果他们之间并不是朋友，但也不敌对，则输出OK；如果他们之间有敌对，然而也有共同的朋友，则输出OK but…；如果他们之间只有敌对关系，则输出No way。 输入样例： 7 8 4 5 6 1 2 7 -1 1 3 1 3 4 1 6 7 -1 1 2 1 1 4 1 2 3 -1 3 4 5 7 2 3 7 2 输出样例： No problem OK OK but... No way 时间限制: 150 ms 内存限制: 64 MB 代码长度限制: 16 KB 其实我拿到这题的第一反应是并——查——集——！！！？？？！！！ 寒假虽然练过并查集的题目，但是没有板子的话就不知道能不能写了。但是并查集的算法原理我是知道的，所以抱着那一丝丝希望，而且如果我写不出来必然会从排行榜跌下去，窝就果断开始写。 首先我们可以把判读敌人和朋友的方法区别开。朋友我采用的是并查集（因为涉及朋友的朋友也是朋友）；敌人我采用的是结构体内部嵌套数组，标记是否直接敌对（只有单纯直接的敌对关系才是绝对不能同席的）。 我的AC代码： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; int father[105]; struct diren { int s[105]; }q[105]; void init(int n) { for(int i=1;i&lt;=n;i++) { father[i]=i; } } int find_father(int n) { if(father[n]==n) return n; else { return find_father(father[n]); } } void Union(int a,int b) { if(a&gt;b) swap(a,b); father[b]=a; } int main() { ios::sync_with_stdio(false); int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; init(n); while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(c==1) { Union(a,b); } else { q[a].s[b]=1; q[b].s[a]=1; } } while(k--) { int a,b; cin&gt;&gt;a&gt;&gt;b; if(q[a].s[b]==1 &amp;&amp; find_father(a)!=find_father(b)) cout&lt;&lt;&quot;No way&quot;&lt;&lt;endl; else if(q[a].s[b]==1) cout&lt;&lt;&quot;OK but...&quot;&lt;&lt;endl; else if(find_father(a)==find_father(b)) cout&lt;&lt;&quot;No problem&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; } return 0; } 但是由于我的并查集是自己靠着理解瞎想的，并不标准，所以接下来推荐大佬代码（所以我为啥不用二维数组要用结构体内嵌数组……我傻了)。 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int pre[101]; int map[101][101]; //邻接矩阵存储两者的直接关系，1朋友 -1敌对 int find(int x){ //寻找 int r = x; while(pre[r]!=r){ r = pre[r]; } int i=x ,j; while(pre[i]!=r){ //路径压缩 j = pre[i]; pre[i] = r; i = j; } return r; } void join(int x,int y){ //将两个集合合并 int fx = find(x); int fy = find(y); if(fx!=fy){ pre[fx] = fy; } } bool same(int x,int y){ //判断两个元素是否在同一个集合中 if(find(x)==find(y)){ return true; }else{ return false; } } int main(){ int n,m,a,b,c,t; cin&gt;&gt;n&gt;&gt;m&gt;&gt;t; for(int i=1 ;i&lt;=n ;i++){ pre[i] = i; } for(int i=1 ;i&lt;=m ;i++){ scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); map[a][b] = c; //记录直接的对应关系 map[b][a] = c; if(c==1){ join(a,b); //间接的朋友关系 } } for(int i=1 ;i&lt;=t; i++){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(map[a][b]==1){ printf(&quot;No problem\\n&quot;); } else if(map[a][b]==-1&amp;&amp;find(a)==find(b)){ printf(&quot;OK but...\\n&quot;); } else if(map[a][b]==-1&amp;&amp;find(a)!=find(b)){ printf(&quot;No way\\n&quot;); } else if(map[a][b]!=-1&amp;&amp;map[a][b]!=1&amp;&amp;find(a)!=find(b)){ printf(&quot;OK\\n&quot;); } } return 0; } 7-11 玩转二叉树 （25 分)给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。 输入格式： 输入第一行给出一个正整数N（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。 输出格式： 在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 输入样例： 7 1 2 3 4 5 6 7 4 1 3 2 6 5 7 输出样例： 4 6 1 7 5 3 2 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB 作为一个二叉树盲，大致扫了一下网上题解发现非常不适合入门级别选手。所以额外找了二叉树的知识点整理一下。(转自指点的专栏) 这棵二叉树一共有7个节点，其中，0号节点叫做根节点，下面的1号节点和2号节点是0号节点的子节点，同时1号节点和2号节点又是3号节点、4号节点和5号节点、6号节点的双亲节点，0号节点有分别以1号节点和2号节点作为根节点的左右子树。5号节点和6号节点没有子节点（子树），那么它们被称为叶子节点。 一般来说，二叉树常用的遍历方式有：前序遍历、中序遍历、后序遍历、层序遍历 四种遍历方式： 1、前序遍历二叉树顺序：根节点 –&gt; 左子树 –&gt; 右子树，即先访问根节点，然后是左子树，最后是右子树。 上图中二叉树的前序遍历结果为：0 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 2、中序遍历二叉树顺序：左子树 –&gt; 根节点 –&gt; 右子树，即先访问左子树，然后是根节点，最后是右子树。 上图中二叉树的中序遍历结果为：3 -&gt; 1 -&gt; 4 -&gt; 0 -&gt; 5 -&gt; 2 -&gt; 6 3、后续遍历二叉树顺序：左子树 –&gt; 右子树 –&gt; 根节点，即先访问左子树，然后是右子树，最后是根节点。 上图中二叉树的后序遍历结果为：3 -&gt; 4 -&gt; 1 -&gt; 5 -&gt; 6 -&gt; 2 -&gt; 0 4、层序遍历二叉树顺序：从最顶层的节点开始，从左往右依次遍历，之后转到第二层，继续从左往右遍历，持续循环，直到所有节点都遍历完成 上图中二叉树的层序遍历结果为：0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 下面给出这四种算法思想的伪代码： 前序遍历： preOrderParse(int n) { if(tree[n] == NULL) return ; // 如果这个节点不存在，那么结束 cout &lt;&lt; tree[n].w ; // 输出当前节点内容 preOrderParse(tree[n].leftChild); // 递归输出左子树 preOrderParse(tree[n].rightChild); // 递归输出右子树 } 中序遍历： inOrderParse(int n) { if(tree[n] == NULL) return ; // 如果这个节点不存在，那么结束 inOrderParse(tree[n].leftChild); // 递归输出左子树 cout &lt;&lt; tree[n].w ; // 输出当前节点内容 inOrderParse(tree[n].rightChild); // 递归输出右子树 } 后续遍历： pastOrderParse(int n) { if(tree[n] == NULL) return ; // 如果这个节点不存在，那么结束 pastOrderParse(tree[n].leftChild); // 递归输出左子树 pastOrderParse(tree[n].rightChild); // 递归输出右子树 cout &lt;&lt; tree[n].w ; // 输出当前节点内容 } 可以看到前三种遍历都是直接通过递归来完成，用递归遍历二叉树简答方便而且好理解，接下来层序遍历就需要动点脑筋了，我们如何将二叉树一层一层的遍历输出？其实在这里我们要借助一种数据结构来完成：队列。 我们都知道，队列是一种先进先出的数据结构，我们可以先将整颗二叉树的根节点加入队尾，然后循环出队，每次读取队头元素输出并且将队头元素出队，然后将这个输出的元素节点的的左右子树分别依次加入队尾，重复这个循环，知道队列为空的时候结束输出。那么整个二叉树就被我们采用层序遍历的思想输出来了。下面我们看一下上图的二叉树用层序遍历思想的遍历步骤： while(!que.empty()) { int n = que.front(); // 得到队头元素 que.pop(); // 队头元素出队列 // 如果当前节点不为空，那么输出节点的数值，并且在队尾插入左右子节点 if(tree[n] != NULL) { cout &lt;&lt; tree[n].w; que.push(tree[n].leftChild); que.push(tree[n].rightChild); } } Ok，下面来看一下这几个遍历算法的最终代码： /* * 二叉树的四种遍历方式，这里没有采用真实的指针去做， * 而是采用数组下标去模拟指针，是一种更加方便快速的方法 */ #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; const int N = 10010; const int INF = -1; //我们用一个常数来表示当前二叉树节点为空的情况 struct Node { int w; // 当前树节点的值 int p; // 当前树节点的双亲所在数组下标 int l; // 当前树节点的左子节点所在数组下标 int r; // 当前树节点的右子节点所在数组下标 }; Node node[N]; // 按照前序遍历二叉树的顺序输入树节点 void input(int n) { cin &gt;&gt; node[n].w; if(node[n].w == INF) //输入-1代表当前节点所在子二叉树停止输入 { return ; } node[n].p = n / 2; node[n].l = n * 2; node[n].r = n * 2 + 1; input(n*2); input(n*2+1); } // 前序遍历二叉树 void preOrderParse(int n) { if(node[n].w == INF) { return ; } cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; preOrderParse(node[n].l); preOrderParse(node[n].r); } // 中序遍历二叉树 void inOrderParse(int n) { if(node[n].w == INF) { return ; } inOrderParse(n*2); cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; inOrderParse(n*2+1); } // 后续遍历二叉树 void postOrderParse(int n) { if(node[n].w == INF) { return ; } postOrderParse(n*2); postOrderParse(n*2+1); cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; } /* * 层序遍历二叉树，这里采用的是 C++ STL 模板的提供的队列(queue)， * 并没有自己去实现一个队列 */ void sequenceParse() { queue&lt;int&gt; que; int n = 1; que.push(1); // 插入根节点所在数组下标 while(!que.empty()) { n = que.front(); que.pop(); // 得到队头元素并且将队头元素出队列 // 如果当前节点不为空，那么输出该节点，并且将该节点的左右子节点插入队尾 if(node[n].w != INF) { cout &lt;&lt; node[n].w &lt;&lt; &quot; &quot;; que.push(node[n].l); que.push(node[n].r); } } } int main() { cout &lt;&lt; &quot;请以前序遍历的顺序输入二叉树，空节点输入 -1 ：&quot; &lt;&lt; endl; input(1); // 从下标为 1 开始前序输入二叉树 cout &lt;&lt; &quot;前序遍历：&quot; &lt;&lt; endl; preOrderParse(1); cout &lt;&lt; endl &lt;&lt; &quot;中序遍历：&quot; &lt;&lt; endl; inOrderParse(1); cout &lt;&lt; endl &lt;&lt; &quot;后序遍历：&quot; &lt;&lt; endl; postOrderParse(1); cout &lt;&lt; endl &lt;&lt; &quot;层序遍历：&quot; &lt;&lt; endl; sequenceParse(); return 0; } 然后回到原题，大体思路就是根据前序、中序序列还原建树，然后镜面反转，就是将非叶子节点的左右孩子互换，最后层序遍历输出这棵树。","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"All Things About STL","slug":"All-Things-About-STL","date":"2019-03-16T00:44:04.000Z","updated":"2020-02-12T05:54:49.782Z","comments":true,"path":"2019/03/16/All-Things-About-STL/","link":"","permalink":"/2019/03/16/All-Things-About-STL/","excerpt":"STL nb！ These violent delights have violent ends. And in their triumph die, like fire and powder, Which, as they kiss, consume.","text":"STL nb！ These violent delights have violent ends. And in their triumph die, like fire and powder, Which, as they kiss, consume. All Things About STL大家好，我是废话 快速了解STLSTL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。(引自百度百科。一堆废话。） STL之Stack(堆栈)堆栈是一个线性表，插入和删除只在表的一端进行。这一端称为栈顶(Stack Top)，另一端则为栈底(Stack Bottom)。堆栈的元素插入称为入栈，元素的删除称为出栈。由于元素的入栈和出栈总在栈顶进行，因此，堆栈是一个后进先出(Last In First Out)表，即 LIFO 表。C++ STL 的堆栈泛化是直接通过现有的序列容器来实现的，默认使用双端队列deque的数据结构，当然，可以采用其他线性结构（vector 或 list等），只要提供堆栈的入栈、出栈、栈顶元素访问和判断是否为空的操作即可。由于堆栈的底层使用的是其他容器，因此，堆栈可看做是一种适配器，将一种容器转换为另一种容器(堆栈容器)。为了严格遵循堆栈的数据后进先出原则，stack 不提供元素的任何迭代器操作，因此，stack 容器也就不会向外部提供可用的前向或反向迭代器类型。stack堆栈容器的C++标准头文件为 stack ，必须用宏语句 “#include “ 包含进来，才可对 stack 堆栈的程序进行编译。 Stack的成员函数 empty() 堆栈为空则返回真 pop() 移除栈顶元素 push() 在栈顶增加元素 size() 返回栈中元素数目 top() 返回栈顶元素 STL之queue（队列）先进先出（FIFO），即插入和删除操作分别在位的不同端。插入元素的那一端为队尾，删除元素的那一端为队首。 queue的成员函数 back() 返回最后一个元素 empty() 如果队列空则返回真 front() 返回第一个元素 pop() 删除第一个元素 push() 在末尾加入一个元素 size() 返回队列中元素的个数 STL之priority queue（优先队列）优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大到小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。 priority queue的成员函数基本操作： empty() 如果队列为空，则返回真 pop() 删除对顶元素，删除第一个元素 push() 加入一个元素 size() 返回优先队列中拥有的元素个数 top() 返回优先队列对顶元素，返回优先队列中有最高优先级的元素 在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。 自定义优先级： //定义结构，使用运算符重载,自定义优先级1 struct cmp1 { bool operator ()(int &amp;a,int &amp;b) { return a&gt;b;//最小值优先 } }; struct cmp2 { bool operator ()(int &amp;a,int &amp;b) { return a&lt;b;//最大值优先 } }; //定义结构，使用运算符重载,自定义优先级2 struct number1 { int x; bool operator &lt; (const number1 &amp;a) const { return x&gt;a.x;//最小值优先 } }; struct number2 { int x; bool operator &lt; (const number2 &amp;a) const { return x&lt;a.x;//最大值优先 } }; priority_queue&lt;int&gt;que;//采用默认优先级构造队列 priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt;que1;//最小值优先 riority_queue&lt;int,vector&lt;int&gt;,cmp2&gt;que2;//最大值优先 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;que3;//注意“&gt;&gt;”会被认为错误，这是右移运算符，所以这里用空格号隔开 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;que4;//最大值优先 priority_queue&lt;number1&gt;que5; priority_queue&lt;number2&gt;que6; 在优先队列中使用结构体的若干小结以结构体Time为例： struct Time { int start, end; }; 使用优先队列时，如果需要对Time中的start从小到大排序，有两种方法： priority_queue&lt;Time&gt; pq; 一.在结构体外重载结构体小于运算符： bool operator &lt;(const Time&amp; a,const Time&amp; b) { return a.start &gt; b.start; } //这里以大于重载小于是因为默认情况下，优先队列是以大的作为队首，这样一反，就可以再默认情况下使得小的作为队首 二.直接在结构体中重载小于运算符： struct Time { int start, end; bool operator &lt; (const Time&amp; t)const { return start &gt; t.start; } }; 实质上来说是一样的。。。。 另外要注意的是：参数列表中的const不能省略，否则报错~~ STL之deque（双端队列）deque与vector非常相似，不仅可以在尾部插入和删除元素，还可以在头部插入和删除。不过当考虑到容器元素的内存分配策略和操作性能时，deque相对vector较为有优势。 deque的成员函数 [ ]：用来访问双向队列中单个的元素。 front()：返回第一个元素的引用。 back()：返回最后一个元素的引用。 push_front(x)：把元素x插入到双向队列的头部。 pop_front()：弹出双向队列的第一个元素。 push_back(x)：把元素x插入到双向队列的尾部。 pop_back()：弹出双向队列的最后一个元素。 STL之vector（引自@博客园_清水汪汪） vector是表示可变大小数组的序列容器。 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。 vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。 与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。 vector的成员函数 容量 向量大小： vec.size(); 向量最大容量： vec.max_size(); 更改向量大小： vec.resize(); 向量真实大小： vec.capacity(); 向量判空： vec.empty(); 减少向量大小到满足元素所占存储空间的大小： vec.shrink_to_fit(); //shrink_to_fit 修改 多个元素赋值： vec.assign(); //类似于初始化时用数组进行赋值 末尾添加元素： vec.push_back(); 末尾删除元素： vec.pop_back(); 任意位置插入元素： vec.insert(); 任意位置删除元素： vec.erase(); 交换两个向量的元素： vec.swap(); 清空向量元素： vec.clear(); 迭代器 开始指针：vec.begin(); 末尾指针：vec.end(); //指向最后一个元素的下一个位置 指向常量的开始指针： vec.cbegin(); //意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾指针： vec.cend(); 元素的访问 下标访问： vec[1]; //并不会检查是否越界 at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常 访问第一个元素： vec.front(); 访问最后一个元素： vec.back(); 返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。 算法 遍历元素vector&lt;int&gt;::iterator it; for (it = vec.begin(); it != vec.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; //或者 for (size_t i = 0; i &lt; vec.size(); i++) { cout &lt;&lt; vec.at(i) &lt;&lt; endl; } 元素翻转#include &lt;algorithm&gt; reverse(vec.begin(), vec.end()); 元素排序#include &lt;algorithm&gt; sort(vec.begin(), vec.end()); //采用的是从小到大的排序 //如果想从大到小排序，可以采用上面反转函数，也可以采用下面方法: bool Comp(const int&amp; a, const int&amp; b) { return a &gt; b; } sort(vec.begin(), vec.end(), Comp); STL之vector,deque对比(引自@开源中国_爱吃冰红茶)vector,deuqe之对比： 随机访问速度：vector &gt; deque。 deque性能损失比vector高几个数量级：因为deque首次插入一个元素时，会默认动态分配512字节空间，当这512字节空间用完后，它会再动态分配自己另外的512字节空间，然后虚拟地连在一起。deque的这种设计使得它具有比vector复杂得多的架构、算法和迭代器设计，也使得性能损失比vector高！ 在插入删除操作时，deque由于vector:对于vector而言，由于其是一端开口，所以在尾部插入耗费固定的时间，而在头部进行插入时，耗费的时间与vector的大小成正比，vector越大，耗费的时间越多。而对于deque,不管插入删除操作是在头部还是尾部进行，算法的效率是固定的。 可以得到，在vector和deque进行插入删除时，deque的效率是高于vector的。当都是在末尾进行插入时，vector和deque的差别不大，但是在对头部进行插入时，差距十分明显。 总结一下：当进行插入删除时候，选择deque，当进行顺序访问时，选择vector。 STL之listList是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件。 list的成员函数 Lst1.assign() ：给list赋值 Lst1.back() ：返回最后一个元素 Lst1.begin() ：返回指向第一个元素的迭代器 Lst1.clear() ：删除所有元素 Lst1.empty() ：如果list是空的则返回true Lst1.end() ：返回末尾的迭代器 Lst1.erase() ：删除一个元素 Lst1.front() ：返回第一个元素 Lst1.get_allocator() ：返回list的配置器 Lst1.insert() ：插入一个元素到list中 Lst1.max_size() ：返回list能容纳的最大元素数量 Lst1.merge() ：合并两个list Lst1.pop_back() ：删除最后一个元素 Lst1.pop_front() ：删除第一个元素 Lst1.push_back() ：在list的末尾添加一个元素 Lst1.push_front() ：在list的头部添加一个元素 Lst1.rbegin() ：返回指向第一个元素的逆向迭代器 Lst1.remove() ：从list删除元素 Lst1.remove_if() ：按指定条件删除元素 Lst1.rend() ：指向list末尾的逆向迭代器 Lst1.resize() ：改变list的大小 Lst1.reverse() ：把list的元素倒转 Lst1.size() ：返回list中的元素个数 Lst1.sort() ：给list排序 Lst1.splice() ：合并两个list Lst1.swap() ：交换两个list Lst1.unique() ：删除list中重复的元素 遍历List for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++) { cout&lt;&lt;*iter; } cout&lt;&lt;endl; STL之mapMap是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。 容器中元素的访问 下标访问 和访问数组一样。map中键是唯一的 迭代器访问 map&lt; typename1 , typename2 &gt;::iterator it; #include&lt;stdio.h&gt; #include&lt;map&gt; using namespace std; int main() { map&lt;char,int&gt; mp; mp[&#39;a&#39;]=5; mp[&#39;b&#39;]=10; mp[&#39;d&#39;]=40; mp[&#39;c&#39;]=20; mp[&#39;c&#39;]=30;//20被覆盖 printf(&quot;%d\\n&quot;,mp[&#39;c&#39;]); for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++) { printf(&quot;%c %d\\n&quot;,it-&gt;first,it-&gt;second); //it-&gt;first:当前映射的键，it-&gt;second:当前映射的值 } //a 5 //b 10 //c 30 //d 40 //map会以键从小到大的顺序自动排序。map内部是使用红黑树实现的，set内部也是。 //建立映射的时候，会自动实现从小到大的排序功能 return 0; } map的成员函数 find() find(key)：返回键为key的映射，时间复杂度为O(logN) erase() 删除单个元素 mp.erase(it)：it为需要删除的元素的迭代器。时间复杂度为O(1) mp.erase(key):key为删除元素的键，时间复杂度为O(logN) 删除区间内的元素 左闭右开[start,end) size() clear() 用来清空map，复杂度为O(N)`c++#include&lt;stdio.h&gt;#include using namespace std; int main(){ map&lt;char,int&gt; mp; mp[‘a’]=5; mp[‘b’]=10; mp[‘d’]=40; mp[‘c’]=20; mp[‘c’]=30;//20被覆盖 printf(“%d\\n”,mp[‘c’]);//30 mp.erase(&#39;b&#39;);//删除键为b的映射，也就是b 10 for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++) { printf(&quot;%c %d\\n&quot;,it-&gt;first,it-&gt;second); } //a 5 //c 30 //d 40 map&lt;char,int&gt;::iterator it=mp.find(&quot;a&quot;); mp.erase(it);//删除a 5 for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++) { printf(&quot;%c %d\\n&quot;,it-&gt;first,it-&gt;second); } //c 30 //d 40 mp[&#39;e&#39;]=50; mp[&#39;f&#39;]=60; map&lt;char,int&gt;::iterator it=mp.find(&quot;d&quot;); mp.erase(it,mp.end());//删除区间， d 40 e 50 return 0; } ### map排序 1. C++ STL中Map的按Key排序 &lt;p style=&quot;text-indent:2em&quot;&gt;其实，为了实现快速查找，map内部本身就是按序存储的（比如红黑树）。在我们插入&lt; key, value&gt;键值对时，就会按照key的大小顺序进行存储。这也是作为key的类型必须能够进行 &lt; 运算比较的原因。现在我们用string类型作为key，因此，我们的存储就是按学生姓名的字典排序储存的。&lt;/p&gt; ```c++ #include&lt;map&gt; #include&lt;string&gt; #include&lt;iostream&gt; using namespace std; typedef pair&lt;string, int&gt; PAIR; ostream&amp; operator&lt;&lt;(ostream&amp; out, const PAIR&amp; p) { return out &lt;&lt; p.first &lt;&lt; &quot;\\t&quot; &lt;&lt; p.second; } int main() { map&lt;string, int&gt; name_score_map; name_score_map[&quot;LiMin&quot;] = 90; name_score_map[&quot;ZiLinMi&quot;] = 79; name_score_map[&quot;BoB&quot;] = 92; name_score_map.insert(make_pair(&quot;Bing&quot;,99)); name_score_map.insert(make_pair(&quot;Albert&quot;,86)); for (map&lt;string, int&gt;::iterator iter = name_score_map.begin();iter != name_score_map.end();++iter) { cout &lt;&lt; *iter &lt;&lt; endl; } return 0; } 现在知道如何为map指定Compare类了，如果我们想自己写一个compare的类，让map按照我们想要的顺序来存储，比如，按照学生姓名的长短排序进行存储，那该怎么做呢？其实很简单，只要我们自己写一个函数对象，实现想要的逻辑，定义map的时候把Compare指定为我们自己编写的这个就ok啦。 struct CmpByKeyLength { bool operator()(const string&amp; k1, const string&amp; k2) { return k1.length() &lt; k2.length(); } }; C++ STL中Map的按Value排序虽然不能直接用sort对map进行排序，那么我们可不可以迂回一下，把map中的元素放到序列容器（如vector）中，然后再对这些元素进行排序呢？这个想法看似是可行的。要对序列容器中的元素进行排序，也有个必要条件：就是容器中的元素必须是可比较的，也就是实现了&lt; 操作的。令人兴奋的是，sort算法和map一样，也可以让我们指定元素间如何进行比较，即指定Compare。需要注意的是，map是在定义时指定的，所以传参的时候直接传入函数对象的类名，就像指定key和value时指定的类型名一样；sort算法是在调用时指定的，需要传入一个对象，当然这个也简单，类名()就会调用构造函数生成对象。 int main() { map&lt;string, int&gt; name_score_map; name_score_map[&quot;LiMin&quot;] = 90; name_score_map[&quot;ZiLinMi&quot;] = 79; name_score_map[&quot;BoB&quot;] = 92; name_score_map.insert(make_pair(&quot;Bing&quot;,99)); name_score_map.insert(make_pair(&quot;Albert&quot;,86)); //把map中元素转存到vector中 vector&lt;PAIR&gt; name_score_vec(name_score_map.begin(), name_score_map.end()); sort(name_score_vec.begin(), name_score_vec.end(), CmpByValue()); // sort(name_score_vec.begin(), name_score_vec.end(), cmp_by_value); for (int i = 0; i != name_score_vec.size(); ++i) { cout &lt;&lt; name_score_vec[i] &lt;&lt; endl; } return 0; } STL之hash_maphash_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。虽然对外部提供的函数和数据类型是一致的，但是其底层实现是完全不同的，map底层的数据结构是rb_tree而，hansh_map却是哈希表来实现的。 map与hash_map总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。hash还有hash函数的耗时。当有100w条记录的时候，map也只需要20次的比较，200w也只需要21次的比较！所以并不一定常数就比log(n) 小！hash_map对空间的要求要比map高很多，所以是以空间换时间的方法，而且，hash_map如果hash函数和hash因子选择不好的话，也许不会达到你要的效果，所以至于用map，还是hash_map，从3个方面来权衡： 查找速度, 数据量, 内存使用，还有一个就是你的经验！没有特别的标准另外可以通过重写 hash_compair仿函数，更改里面关于桶数量的定义，如果取值合适，也可以得到更优的性能。而且如果你的数据是自定义的类型，必须要重写这个仿函数。可以模仿原来的写法，所有的成员函数，成员变量一个不能少！ STL之multimap标准库还定义了一个 multimap 容器，它与 map 类似，所不同的是它允许重复键。这个属性使得 multimap 比预想的要更有用：比如在电话簿中相同的人可以有两个以上电话号码，文件系统中可以将多个符号链接映射到相同的物理文件，或DNS服务器可以将几个URLs映射到相同的IP地址。 multimap的成员函数 begin() :返回指向第一个元素的迭代器 clear() :删除所有元素 count() :返回一个元素出现的次数 empty() :如果multimap为空则返回真 end() :返回一个指向multimap末尾的迭代器 equal_range() :返回指向元素的key为指定值的迭代器对 erase() :删除元素 find() :查找元素 get_allocator() :返回multimap的配置器 insert() :插入元素 key_comp() :返回比较key的函数 lower_bound() :返回键值&gt;=给定元素的第一个位置 max_size() :返回可以容纳的最大元素个数 rbegin() :返回一个指向mulitmap尾部的逆向迭代器 rend() :返回一个指向multimap头部的逆向迭代器 size() :返回multimap中元素的个数 swap() :交换两个multimaps upper_bound() :返回键值&gt;给定元素的第一个位置 value_comp() :返回比较元素value的函数 //multimap允许重复的键值插入容器 // ********************************************************** // * pair只包含一对数值:pair&lt;int,char&gt; * // * map是一个集合类型，永远保持排好序的， * // * map每一个成员就是一个pair,例如：map&lt;int,char&gt; * // * map的insert()可以把一个pair对象作为map的参数,例如map&lt;p&gt; * // *********************************************************** #include&lt;map&gt; #include&lt;iostream&gt; using namespace std; int main(void) { multimap&lt;int,char*&gt; m; //multimap的插入只能用insert()不能用数组 m.insert(pair&lt;int,char*&gt;(1,&quot;apple&quot;)); m.insert(pair&lt;int,char*&gt;(1,&quot;pear&quot;)); //apple和pear的价钱完全有可能是一样的 m.insert(pair&lt;int,char*&gt;(2,&quot;banana&quot;)); //multimap的遍历只能用迭代器方式不能用数组 cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; multimap&lt;int,char*&gt;::iterator i,iend; iend=m.end(); for(i=m.begin();i!=iend;i++) { cout&lt;&lt;(*i).second&lt;&lt;&quot;的价钱是&quot;&lt;&lt;(*i).first&lt;&lt;&quot;元/斤n&quot;; } cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; //元素的反相遍历 multimap&lt;int,char*&gt;::reverse_iterator j,jend; jend=m.rend(); for(j=m.rbegin();j!=jend;j++) { cout&lt;&lt;(*j).second&lt;&lt;&quot;的价钱是&quot; &lt;&lt;(*j).first&lt;&lt;&quot;元/斤n&quot;; } cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; //元素的搜索find(),pair&lt;iterator,iterator&gt;equal_range(const key_type &amp;k)const //和multiset的用法一样 multimap&lt;int,char*&gt;::iterator s; s=m.find(1);//find()只要找到一个就行了，然后立即返回。 cout&lt;&lt;(*s).second&lt;&lt;&quot; &quot; &lt;&lt;(*s).first&lt;&lt;endl; cout&lt;&lt;&quot;键值等于1的元素个数是：&quot;&lt;&lt;m.count(1)&lt;&lt;endl; cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; //删除 erase(),clear() m.erase(1); for(i=m.begin();i!=iend;i++) { cout&lt;&lt;(*i).second&lt;&lt;&quot;的价钱是&quot; &lt;&lt;(*i).first&lt;&lt;&quot;元/斤n&quot;; } return 0; } 遍历// 使用遍历器遍历： Iterator iter = map.entries().iterator(); while(iter.hasNext()) { Map.Entry&lt;Integer, Integer&gt; entry = (Map.Entry&lt;Integer, Integer&gt;)iter.next(); System.out.println(String.format(&quot;%d:%d&quot;, entry.getKey(),entry.getValue())); } //使用Key值遍历，key值可以得到一个全部键值的MultiSet或者是一个没有重复键值的KeySet Set&lt;Integer&gt; keys = map.keySet(); for(int key:keys) { String result = String.format(&quot;%d:&quot;, key); Set&lt;Integer&gt; values = map.get(key); for(int value:values) { result= result+&quot; &quot;+value; } System.out.println(result); } STL之setset，顾名思义，就是数学上的集合——每个元素最多只出现一次，并且set中的元素已经从小到大排好序。 set的成员函数 begin() :返回set容器的第一个元素的地址 end() :返回set容器的最后一个元素地址 clear() :删除set容器中的所有的元素 empty() :判断set容器是否为空 max_size() :返回set容器可能包含的元素最大个数 size() :返回当前set容器中的元素个数 erase(it) :删除迭代器指针it处元素`c++#include #include using namespace std; int main(){ set s; s.insert(1); s.insert(2); s.insert(3); s.insert(1); cout&lt;&lt;”set 的 size 值为 ：”&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;”set 的 maxsize的值为 ：”&lt;&lt;s.max_size()&lt;&lt;endl; cout&lt;&lt;”set 中的第一个元素是 ：”&lt;&lt;s.begin()&lt;&lt;endl; cout&lt;&lt;”set 中的最后一个元素是:”&lt;&lt;s.end()&lt;&lt;endl; s.clear(); if(s.empty()) { cout&lt;&lt;”set 为空 ！！！”&lt;&lt;endl; } cout&lt;&lt;”set 的 size 值为 ：”&lt;&lt;s.size()&lt;&lt;endl; cout&lt;&lt;”set 的 maxsize的值为 ：”&lt;&lt;s.max_size()&lt;&lt;endl; return 0;} - count() :用来查找set中某个元素出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。 - find(): 用来查找set中某个元素出现的位置。如果找到，就返回这个元素的迭代器，如果这个元素不存在，则返回 s.end() 。 (最后一个元素的下一个位置，s为set的变量名) ```c++ #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { set&lt;int&gt; s; set&lt;int&gt;::iterator it; //创建一个他对应的迭代器 s.insert(1); s.insert(2); s.insert(3); s.insert(1); cout&lt;&lt;&quot;set 中 1 出现的次数是 ：&quot;&lt;&lt;s.count(1)&lt;&lt;endl; cout&lt;&lt;&quot;set 中 4 出现的次数是 ：&quot;&lt;&lt;s.count(4)&lt;&lt;endl; it1 = st1.find(4); //查找数据 if (it1 != st1.end()) //如果找到就输出数据 { cout &lt;&lt; *it1 &lt;&lt; endl; } return 0; } 遍历`c++##include #includeusing namespace std; int main(){ set s; //创建一个int类型的set s.insert(10); //插入数据 s.insert(30); s.insert(20); s.insert(40); //遍历数据，用迭代器遍历数据 for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); ++it) { cout &lt;&lt; *it &lt;&lt; endl; } //这里用到了set中的元素已经从小到大排好序的性质 return 0; } - set+struct ```c++ #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;string&gt; using namespace std; struct Info { string name; double score; bool operator &lt; (const Info &amp;a) const // 重载“&lt;”操作符，自定义排序规则 { //按score由大到小排序。如果要由小到大排序，使用“&gt;”即可。 return a.score &lt; score; } }; int main() { set&lt;Info&gt; s; Info info; //插入三个元素 info.name = &quot;Jack&quot;; info.score = 80; s.insert(info); info.name = &quot;Tom&quot;; info.score = 99; s.insert(info); info.name = &quot;Steaven&quot;; info.score = 60; s.insert(info); set&lt;Info&gt;::iterator it; for(it = s.begin(); it != s.end(); it++) cout &lt;&lt; (*it).name &lt;&lt; &quot; : &quot; &lt;&lt; (*it).score &lt;&lt; endl; return 0; } /* 运行结果： Tom : 99 Jack : 80 Steaven : 60 */","categories":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}],"tags":[{"name":"STL","slug":"STL","permalink":"/tags/STL/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"/categories/算法/"}]},{"title":"冬日即事","slug":"冬日即事","date":"2019-02-11T10:52:28.000Z","updated":"2020-02-12T06:25:37.896Z","comments":true,"path":"2019/02/11/冬日即事/","link":"","permalink":"/2019/02/11/冬日即事/","excerpt":"似乎……很久没有写过正儿八经的文章了。","text":"似乎……很久没有写过正儿八经的文章了。 冬日即事1从北方回来的列车上，对南方的想念，越来越浓。窗外的景色，由北至南的，色调变换着。旁边的学姐睡得很香，只能看起了昨晚下载的《人间世》，两集而已，一直在流泪。 学姐在临海站提前下了。再过一站便是台州站。拎起行李，出了检票口，父母已经等在外面。没有想象中的热泪盈眶，那些太假。一切的想念已经融在自然接过行李的一举一动里。 刚回来的几天，只见了来找我的盈盈一面。我们一起吃了顿午饭，还放了风筝。和盈盈的感情不言而喻，不需要太多的文字交流，却能在每次见面的时候还保持高中时候的感觉。大概平平淡淡才是真吧。 然后有天我和钰莹说，我想好怎么给他新年祝福啦，最后的一句一定是“友谊地久天长”。她很惊异，似乎过了好一会儿才接受了这个我已做好的决定。大概知道的人都会好奇原因吧。 ——觉得我性子张扬的人，怕是没见过我在学生会换届选举的时候，紧张到把一句感谢上届部长的话陆陆续续说了七遍；觉得我安静内敛的人，也怕是没见过我和学妹们打打闹闹，话特别多。我是一个很矛盾的人，所以同时，感性和理性相互交错，也就没什么奇怪的了吧。我会因为一件很小很小的事感动很久，很容易产生对他人的好感；我也会清楚自己的底线，自己的原则：我愿意走五十一步来等你的四十九步，但是不可能再多一步。九十九步换一步这种事情，我也不愿意。 所以就这样吧。不能说他对我来说已经成为一个陌生人，恰恰相反，我还是把他当成很好很好的朋友，而且他会是我一直感谢着的人，我会真诚地祝他幸福。最后写给他的新年祝福写了很久，字斟句酌，还问了钰莹和紫闻的意见。点了发送以后知道自己不能再回头，其实挺好的，不想再因为自己的任性自私伤害别人了。 由于时间原因，新年祝福只准备了特别的两份，一份给了钰莹，一份给了紫闻，感谢他们在新的开始给我的温暖。钰莹是那个会在回家的火车上还想着给穷困潦倒的我寄些水果来的善良女孩，而紫闻是接到我的求助电话会专门从综合楼跑过来帮忙搬东西的宝藏男孩。没有他们的话，大抵又穷又饿又绝望的我会在这个冬天慢慢枯萎吧（大雾~ 2新年来的很快。 其实感觉已经丧失了过年的仪式感。吃的也差不多，穿的也差不多，连日常都还是敲代码。这个假期学会了数据结构、并查集，其实感觉已经差不多了，对于stack、queue、priority queue、map、vector的使用已经比较熟练了。cf的得分也差不多稳定在了1450左右，三题差不多的水平。 关于抑郁症的说明。大概有了亲身体会，会明白ACM这个圈子是多么容易患抑郁症的一个群体。心情的慢慢变化大概就在新年以后发生的。疑心自己有这个倾向以后，去找了一个相对专业的测试，结果也差不多：中度抑郁。引用测试报告里的话：“情绪抑郁时，你可能会告诉自己，你天生就没用或者就是‘一无是处’。你越来越肯定你就是个坏胚子，一点好处都没用。你对这种想法深信不疑，于是，你产生了严重的情绪反应，你开始感到绝望，越来越憎恨自己。你甚至会觉得不如死了算了，因为你把自己贬的太低，觉得活着太痛苦了。你还可能会自闭封锁自己，既害怕也不愿意投入正常的生活。” 不过我不想死。很明白地知道，我不想死，不会自杀。大概属于第二种吧。这不是camp时挂在嘴边的那种意义上的自闭，自黑自嘲而已，而是，真的觉得自己菜，不想去祸害别人，去打扰别人。 这件事我告诉的人很少，包括我的父母，我没有说过一个字，让他们心中的女儿一直健康美好地存在着，挺好的。第一个说的人还是他，鬼使神差地，只是想起之前失眠时候他给的建议，就跟他提了，不过没有说的这么严重。没有想得到有用的建议，只是单纯地，想找个人倾诉。但是，似乎，没有得到相应的释然的感觉。 盈盈，钰莹，紫闻差不多是同一时间说的。大概紫闻以为我在开玩笑吧QWQ，但是盈宝和钰莹都挺担心我这种状态的，让我不妨松一松。再之后是表弟突然和我说他有自杀倾向的时候，因为我自己的情况吧，所以很担心他，拼命地打字希望他看进去，不要冲动。 感觉到了自己的异样以后，我基本就把训练慢下来了，cf也不是场场都打。调整了一段时间以后感觉恢复得差不多，就答应了西北大学学长那边组队cf的邀请。但是那场平常带飞的学长鸽了，所以我从一开始就紧张的要命，是那种比第一场还紧张的感觉。最后B果然在WA的道路上越走越远，虽说抢救回来了，但是浪费了很多时间。最后这场xj变蓝了——那种内心压抑很久的抑郁，终于喷涌而出。 脑海里只剩下一个字，菜。jp学长刚好在和我聊天，就感觉到了不对劲，也很担心我这个样子，疯狂劝我换一个地方大展身手。可是怎么能离开呢？我兢兢业业打了一学期的ACM呀，我遇到了很多志同道合的小伙伴的ACM呀，最最最好玩的ACM呀。 其实客观地说，我觉得一个新手能走到现在这个程度，已经很不错了。但是走得越快越远，给自己的期望越大，压力越大，自然，就受不了了。 3台中还是印象里的台中。 正月初七，宜，回校宣讲。 我见到了阔别已久的同学，还有男神徐老师。尤其好玩的是，早上和jp学长漫步校园说话的时候，一男子骑车飘过，叫了声我的名字。愣了一下反应过来是谁的时候，人已经飘远了。刚想给他发信息解释一下的时候，就收到了他无比哀怨的信息“你忘记我了”。其实是小学同学，没想到，哈哈哈，一下子就认出我了，tql。 徐老师开完会就回到办公室等我们了。我到的时候他和盈盈已经在说话了。其实是怕独处太尴尬才拉了盈盈，不然见男神这种事当然要自己来呀！他跟我们聊了在北京过年的经历，顺便关心了下我的大学生活，还是很惊讶他心中的文科妹子去读了计算机hhh。 本来不应该是初七这么热闹的日子回来的，原意是为了见交大小哥哥一面，毕竟他马上要出国了，然而他有事鸽了QAQ。高考以后慢慢想变得不再那么关心这个小哥哥的事情，但是总会在想起来的时候不自觉地微笑。是很好的人呀，可惜我那么幸运去华东师大继续做他对面的学妹，甚至在上海都找不到什么合适的学校。呆呆，你一定会越来越优秀的！你是那么善良的小天使，从来都不用恶意揣测别人，还会在复习的重要关头每天都给一个刚熟起来的学妹辅导化学。你是我心里最文理兼修的典范！ 4知道散人是很凑巧的机缘。 本来在水哥走后，对《最强大脑》有些嗤之以鼻。但是得知高中同学进了百强以后，还是去看了，就知道了有逍遥散人这个宝藏男孩。去B站搜他的视频，其实一开始吸引我的是橙光小游戏！！！哈哈哈，他录的《龙雏》和《家族史》我都玩过，但是！他作为一直直得不能再直的直男，居然在两代六条BG线中完美绕行，打出了两条仅有的BL线，哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈，我笑爆了。 然后接下来一天我都在看他的游戏小视频。I Wanna系列可真是个宝藏。本来这个游戏就难度极高，散散上一秒还在吹水，下一秒就能真香，平均死亡时间绝对在5s以内。再加上散老师操着一口天津腔，时不时开启他的直男直觉，心机模式。我整整笑了一天，然后就发现，生活没有那么艰辛了，不是吗？ 于是我顺利成为散散粉丝中98.5%的女粉的一员。张骏xxx关逍遥散人啥事呢？上一个二次元男神轻薄的假相（也是天津人！我tm吹爆天津汉子）也说过：“萌声不萌人。”一起快乐就完事了。 发现自己说了一堆废话啊~可能这篇文章不会被人发现吧，那我就不要脸地放自拍啦！小仙女当然最喜欢拍照呀！","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"回忆","slug":"回忆","permalink":"/tags/回忆/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"Yisin的数据结构小练习（堆栈+队列）","slug":"Yisin的数据结构小练习（堆栈-队列）","date":"2019-02-02T07:25:11.000Z","updated":"2020-02-12T05:31:58.383Z","comments":true,"path":"2019/02/02/Yisin的数据结构小练习（堆栈-队列）/","link":"","permalink":"/2019/02/02/Yisin的数据结构小练习（堆栈-队列）/","excerpt":"人一我百!人十我万!永不放弃~~~ 怀着自信的心,去追逐梦想 ——kuangbin","text":"人一我百!人十我万!永不放弃~~~ 怀着自信的心,去追逐梦想 ——kuangbin Yisin的数据结构小练习（堆栈+队列）VJ套题题目&lt;–点这里 Password：woyaoac A.OpenJ_Bailian2694.逆波兰表达式逆波兰表达式应该是数据结构入门级别的一道题，然而选的这道题有点小坑，所以写了差不多一个多小时。 后缀的逆波兰式应该是很好写的，但是题目给了前缀表达式。一开始不知道正解应该从右到左逆序读入，就和后缀表达式做法一样了。走了很多弯路：开了符号和数字两个栈，检测到连续push两个数字，则符号顶端出栈，对两个数字进行操作后入栈。当然这个想法错的离谱…… 实现逆序读入我们也可以开一个string类型的栈，全部读入后再依次出栈。是数字则进入double类型的栈，检测到是操作符则从double栈中取出两个元素，计算后再入栈。最后double栈中剩余的元素就是答案了。 AC代码如下： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include &lt;stack&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include &lt;stdlib.h&gt; #include &lt;iomanip&gt; using namespace std; int main() { string s; stack&lt;double&gt;num; stack&lt;string&gt;S; int y=0; while(cin&gt;&gt;s) { S.push(s); char a=getchar(); if(a==&#39;\\n&#39;) break; } while(!S.empty()) { s=S.top(); S.pop(); if(s==&quot;+&quot;||s==&quot;-&quot;||s==&quot;*&quot;||s==&quot;/&quot;) { char c=s[0]; double a,b; a=num.top(); num.pop(); b=num.top(); num.pop(); if(c==&#39;+&#39;) num.push(a+b); else if(c==&#39;-&#39;) num.push(a-b); else if(c==&#39;*&#39;) num.push(b*a); else if(c==&#39;/&#39;) num.push(a/b); } else { num.push(atof(s.c_str())); } } printf(&quot;%f\\n&quot;,num.top()); return 0; } B.ZOJ 3210.A Stack or A Queue?B题着实水啊，基本就是概念检测题，判断stack、queue、both or neither。只要从前往后扫一遍，在从后往前扫一遍，就可以得出答案。 AC代码如下： #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; int a[105],b[105]; for(int i=0;i&lt;m;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;m;i++) cin&gt;&gt;b[i]; int flag1=0,flag2=0; for(int i=0;i&lt;m;i++) { if(a[i]!=b[i]) { flag1=1; break; } } for(int i=0;i&lt;m;i++) { if(a[i]!=b[m-1-i]) { flag2=1; break; } } if(flag1==0&amp;&amp;flag2==0) cout&lt;&lt;&quot;both&quot;&lt;&lt;endl; else if(flag1==0) cout&lt;&lt;&quot;queue&quot;&lt;&lt;endl; else if(flag2==0) cout&lt;&lt;&quot;stack&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;neither&quot;&lt;&lt;endl; } return 0; } C.CodeForces 1104B.Game with string这题是临时换上去的，cf开模拟赛的时候写了这道题感觉比较有价值，就拿过来了。虽然不知道官答是不是用栈写的。（刚才去翻了一下列表，这题应该是典型栈题无疑。） 一个类似于消消乐的操作，相邻元素相同可消，消了以后左右合并，求最大消除总次数。用栈来模拟，遍历字符串，和栈顶元素不同则入栈，相同则取出栈顶元素。 AC代码如下： #include&lt;bits/stdc++.h&gt; #define ll long long #define U unsigned #define sqr(x) ((x)*(x)) #define mem(x,y) memset(x,y,sizeof(x)) #define scd(x) scanf(&quot;%d&quot;,&amp;x) #define scs(x) scanf(&quot;%s&quot;,&amp;x) #define prd(x) printf(&quot;%d&quot;,x) #define prs(x) printf(&quot;%s&quot;,x) #define rep0(x,n) for(int x=0;x&lt;n;x++) #define rep1(x,n) for(int x=1;x&lt;=n;x++) #define per(x,a,b) for(int x=a;x&gt;=b;x--) #define ls rt&lt;&lt;1 #define rs rt&lt;&lt;1|1 #define lson l,m,ls #define rson m+1,r,rs using namespace std; const double eps=1e-8; const double pi=acos(-1.0); const int INF=0x3f3f3f3f; ll gcd(ll a,ll b){return b?gcd(b,a%b):a;} int lcm(int a,int b){return a/gcd(a,b)*b;} ll powmod(ll a,ll b,ll MOD){ll ans=1;while(b){if(b%2)ans=ans*a%MOD;a=a*a%MOD;b/=2;}return ans;} int main() { ios::sync_with_stdio(false); stack&lt;char&gt;game; string s; cin&gt;&gt;s; int ans=0; game.push(s[0]); for(int i=1;i&lt;s.size();i++) { if(game.size()==0) game.push(s[i]); else if(s[i]==game.top()) { game.pop(); ans++; } else { game.push(s[i]); } } if(ans%2==1) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; return 0; } D.ZOJ 1259.RailsRails是经典的栈题。这是一道入门火车问题。唯一觉得有点烦的是input数据格式怎么这么麻烦。 我们需要两个数组s1，s2和一个stack。s1存放要求的出站顺序，s2存放入站顺序（也就是1-n）。进行数组匹配（不知道能不能这么描述），倘若一样，下一个；不一样，先看看s2和栈顶元素是否相同。相同则栈顶元素出栈，s1元素地址++；不相同则把s2元素入栈，s2元素地址++，直到找到s2中与s1相同的一项，或者s2到达末尾匹配失败。 AC代码如下： #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;cstring&gt; using namespace std; int a[1005],b[1005]; int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); stack&lt;int&gt; s; while(cin&gt;&gt;a[0]) { b[0]=1; int i=0,j=0; if(a[0]==0) { cout&lt;&lt;endl; break; } else { for(int k=1;k&lt;n;k++) { cin&gt;&gt;a[k]; b[k]=k+1; } for(i=0;i&lt;n;i++) { if(a[i]==b[j]) { j++; } else { if(!s.empty()) { if(s.top()==a[i]) { s.pop(); } else { s.push(b[j]); j++; i--; } } else { s.push(b[j]); j++; i--; } } if(j&gt;n) break; } } if(i==n) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } } return 0; } E.ZOJ 2603.Railroad Sort这道火车题在栈的基础上增加了二分分治思想，对递归写的不太好的我来说还是有些困难的。 通过n个站台使2^n辆无序火车有序出站，最简单的安排方式就是通过第一个站台使前2^(n-1)辆火车先出站，通过第二个站台使前2^(n-2)辆火车先出站…… 拿例子8 4 7 1 3 6 5 2举例的话， 1 : 4 1 3 2 | 8 7 6 5 2 : 1 2 | 4 3 | 6 5 | 8 7 3 ： 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 通过一个栈结构，实现每次二分的排序。 AC代码如下： #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int a[10005]; void dfs(int num[],int r,int k) { if(k&lt;=1) return ; int s1[k/2+1]; int s2[k/2+1]; int k1=0,k2=k/2; int l=r-k; int mid=(l+r)/2; stack&lt;int&gt; si; int p1=0,p2=0; for(int i=0;i&lt;k;i++) { if(num[i]&lt;=mid) { s1[p1++]=num[i]; cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;&lt;&lt;num[i]&lt;&lt;&quot; &quot;; } else { cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; si.push(num[i]); } } while(!si.empty()) { s2[p2]=si.top(); si.pop(); cout&lt;&lt;s2[p2++]&lt;&lt;&quot; &quot;; } dfs(s1,mid,k/2); dfs(s2,r,k/2); return ; } int main() { int n; while(cin&gt;&gt;n&amp;&amp;n) { int m=1&lt;&lt;n; for(int i=0;i&lt;m;i++) cin&gt;&gt;a[i]; dfs(a,m,m); cout&lt;&lt;endl; } return 0; } F.HDU 1023.Train Problem II其实这不算数据结构的题，是排列组合问题下的计数问题，卡特兰数的应用。 详细题解可以移步kuangbin 巨巨的blog。 AC代码： #include&lt;iostream&gt; using namespace std; int a[105][105]; void ktl() { int i,j,yu,len; a[2][0]=a[1][0]=a[1][1]=1; a[2][1]=2; len=1; for(int i=3;i&lt;101;i++) { yu=0; for(int j=1;j&lt;=len;j++) { int t=(a[i-1][j])*(4*i-2)+yu; yu=t/10; a[i][j]=t%10; } while(yu) { a[i][++len]=yu%10; yu/=10; } for(j=len;j&gt;=1;j--) { int t=a[i][j]+yu*10; a[i][j]=t/(i+1); yu=t%(i+1); } while(!a[i][len]) { len--; } a[i][0]=len; } } int main() { ktl(); int n; while(cin&gt;&gt;n) { for(int i=a[n][0];i&gt;0;i--) { cout&lt;&lt;a[n][i]; } cout&lt;&lt;endl; } return 0; } G.ZOJ 1151.Word Reversal题意为给出一句话，对每个单词翻转其中字母的顺序。 网上看到的方法感觉比较繁琐，我给出的思路是读取字符串s，对于每一位判断是否为空格，非空格则入栈，为空格则依次出栈。循环结束后还需要把最后一个单词的字母出栈。 AC代码如下： #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;string&gt; #include&lt;cstdio&gt; using namespace std; int main() { int n; cin&gt;&gt;n; while(n--) { int m; cin&gt;&gt;m; getchar(); while(m--) { string s; getline(cin,s); stack&lt;char&gt; q; for(int i=0;i&lt;s.size();i++) { if(s[i]!=&#39; &#39;) q.push(s[i]); else { while(!q.empty()) { cout&lt;&lt;q.top(); q.pop(); } cout&lt;&lt;&quot; &quot;; } } while(!q.empty()) { cout&lt;&lt;q.top(); q.pop(); } cout&lt;&lt;endl; } if(n&gt;0) cout&lt;&lt;endl; } return 0; } H.HDU 3351.Seinfeld括号配对问题的升级版，问给出一串括号序列，最少需要多少次反转操作，使全部括号配对成功。 利用贪心思想可知，先消去配对成功的括号，再对剩下括号操作。开一个栈，若是 { 则入栈， } 要先判断栈是否为空：若为空，则可知这个括号一定需要反转；不为空，则可配对消除，使一个 { 出栈。遍历一遍以后，栈内余下的左括号需要把其中一半变为右括号，使之配对成功。 AC代码如下： #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;cstdio&gt; #include&lt;string&gt; using namespace std; int main() { string s; getline(cin,s); int m=1; while(s[0]!=&#39;-&#39;) { stack&lt;char&gt;q; int ans=0; for(int i=0;i&lt;s.size();i++) { if(s[i]==&#39;{&#39;) { q.push(&#39;{&#39;); } else { if(q.empty()) { ans++; q.push(&#39;{&#39;); } else q.pop(); } } ans+=q.size()/2; cout&lt;&lt;m&lt;&lt;&quot;. &quot;; m++; cout&lt;&lt;ans&lt;&lt;endl; getline(cin,s); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"STL","slug":"STL","permalink":"/tags/STL/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"岁末有感","slug":"岁末有感","date":"2019-01-28T10:21:05.000Z","updated":"2020-02-12T05:55:28.521Z","comments":true,"path":"2019/01/28/岁末有感/","link":"","permalink":"/2019/01/28/岁末有感/","excerpt":"愿你心中有丘壑，眉目做山河 从此无心爱良夜 任他明月下西楼","text":"愿你心中有丘壑，眉目做山河 从此无心爱良夜 任他明月下西楼 岁末有感如果要总结这一年的话，似乎要从高三后半段开始讲起呢。 高三时候的我么？ 怎么说呢，我在班主任的眼里大概是有点犟又奇奇怪怪的人吧：高三还不好好收收心准备高考，非要停课去搞什么诗词；自习课又不好好待在教室里，非要跑到大教室去待着；模拟考回回都还可以，怎么一到大考就全炸了。我不和她吵，她也从来就没说服过我，我决意的事一向是由着自己性子去做的。 但在其他老师眼中，又有些不同了。语文老师眼里的乖小孩；历史老师眼里的同道中人，“有希望上浙大的学生”（但那个时候选考已经考炸了QAQ）；数学老师眼里上课就没好好听过，基本在睡觉的学生；英语老师眼里有潜力但是又懒得一匹的学生；语文备课组组长眼里每次语文考试作文水平根本就没发挥出来的学生（其实我觉得吧，他说得多了，我就觉得我作文可能真就这个水平）。 一向和老师们相处得都还不错。无论是哪一阶段，总会有关系超级好的老师关照。同学的话，大概是属于那种一半的人不熟，另一半关系还不错，其中又有几个超级亲密。这种东西一向随缘，关系好必然有关系好的理由：和老师关系好可能是因为和他的观点相通，有引为知己的味道（譬如历史老师）；和同学关系好就大概是因着性格相近，接触的机会比较多（譬如高中时候的盈盈和大学时候的钰莹）。 高三的时候其实比高一高二轻松多了，特别是下半学期。只剩语数英三门。对我来说的话，主要就是数学，怎么从不及格（高三开始的时候只能考七八十吧）提到110+就差不多了。但是也没有想象的那么痛苦，开始好好搞数学的时候，提分的速度还是相当快的，基本每次统练都能进步10分，到最后，已经能稳定100分了。其实还是蛮诧异的，因为他们在外面补习的话，懂的知识点的确比我多，但是……我会做的一般不会丢太多分。所以出来的成绩有时候还会比他们高（笑哭）。 高三值得一提的还有去杭电的三一。其实准备三一的过程就是我忙里偷闲，趁机玩一玩的过程。比别人花了更多时间准备，一方面是做事一向未雨绸缪，另一方面，读书太累了啊。 杭电很气派，三一组织的也很好。很感谢这次三一，改变了一个选考爆炸的小可怜的命运。笔试的话因为选考技术加上文科生，所以很占优势。勉勉强强卡线过的。面试是我弱项，但是聊天就不是。所以我尽量放宽心就当和考官在随意扯家常，而且是往我懂的地方扯。结果一个不小心给自己挖坑，回答了很多科技方面的问题（说个笑话，我知道的科技相关的东西全是为平时考试作文服务的）。从杭州回来自我感觉就不错，遂放宽心，知道不管怎么样杭电还是能读的，不会去读台州学院的。（雾） 接下去的高三就很乏味可陈了。按部就班地复习，连历史课都没得上了，没法听徐老师的百家讲坛了啊。高考前夕意外的冷静。之前这种升学考永远是失眠+噩梦，然后就史无前例的垃圾成绩。高考考场答题也比较稳，跟平时感觉差不多，可能还要再好上一点。 高考结束后就马上去杭州了。一是为了冲一冲复旦和交大的三一，二是想散散心。和一个同班同学结伴，住到了她亲戚家。第一天上午考复旦，下午考交大，杭州的交通嘛……那天真的是一直在匆匆忙忙地跑。感受了一下试题的难度，嘛，对没有数竞经验的人来说相当不友好，而且历史和语文知识面真的，广的可怕，大概就五分之一（可能没有）的东西我见过。 当然是毫无疑问就出局了。接下去就可以肆意玩了。我们去了西湖，去了各大商场，去了杭州最大的服装市场，去了博物馆，寄情于山水之间，全然不在意过去的高考了。 成绩出的还是很快的。大概就在回台州过后没几天。看到总分着实有些惊讶，比预计的高，特别是语文。但是这个成绩呢，又是一个尴尬的位置，浙江快到两万的水平。杭电杭电，食之无味，弃之可惜。填三一的话，基本就是提前批录取；不填提前批的话，风险会有一点，但问题也不大。抱着这样的想法，杭电的三一就主动放弃了，虽然面试分数真的蛮高的。 专业的话，其实我还是目标比较明确的：历史，汉语言文学，计算机。哪个都成。历史被我爸毙掉了…….汉语言文学的话，浙师大的分都不够（微笑），更别说一直心心念念的南开和华师大，学这个学校还是很关键的，所以我主动放弃。然后我爸就开始做我工作，想报一些经济类的专业（我半毛钱兴趣都没有），然后就填的不情不愿。 其实觉得我填的第一志愿还蛮有意思的，是一个第一次放在普通批招生的学校。上海海军军医大学，八年临床本硕博连读。本来以为有可能爆冷的，我太小看浙江人的智慧了哈哈哈。 东秦的计算机是第四十五个志愿，现在都还记得很清楚。如果不是东秦的话，大概就是辽大的经济。命运就是这么有趣，总会有它运行的规律。我注定是要学计算机的女人，注定是要离开南方的姑娘。 之前对东秦完全不了解，发现这个“宝藏”学校的是我爸爸，从一堆奇奇怪怪的河北高校里把它挑出来了。抱着随遇而安的想法，老老实实地看了好久东秦的资料，然后去找找有没有高中上届的学长学姐。 遇到ACM Club是一个转折点。之前虽然选考技术，但是VB是真的太简单了，学的算法也就是小儿科。但是对学习c++概念有极大帮助。我比club开课早了一个星期来学c语言，而且club开课后极长一段时间我还是不会c++。哈哈哈所以说我学东西不是很快，其实也不是转不过弯，就是懒得转…… 和紫闻抢榜首的那段时间刺激极了。每晚不到两点真的没法睡觉。然后就被他拉入了邪恶组织（大雾），先刷本校oj，再去写vj的训练。知道有那么多有oi基础的同学，说不慌是不可能的。化压力为动力嘛。暑假后来就没有去玩啦，开始入门ACM（其实都算不上）。 踏上来秦皇岛的火车之前内心惴惴不安，不知道未来会发生什么。火车走得很慢，夜里睡不着，只有一轮明月始终相伴。 成功面基紫闻、谜语学长，然后才见到传说中的50er。大概很多事情都会随着时间推移慢慢改变，只是当时还不知道。所幸终有不变的值得珍惜的东西。就已经很好了。 军训的时候一天比一天黑。但是却是经历的最轻松的一个军训，太好划水了。所以也没有什么独特的记忆，似乎只是平平淡淡的一个星期。对着一群人脸盲，叫不上名字。进入一个新环境的过渡期总是难受极了。 进入ACM Club很顺利，并没有什么曲折。面试的学姐也是暑假认识的浙江小姐姐，水水就放我走了。进入预备队反而是有些险了，第一次差点掉出前十。进入club以后就开始迷茫了，一是因为50er退役带来的冲击太大，还有就是不知道自己的定位，也不知道什么时候离开。爸爸的期望还是很高的，希望能进EC Final，并且夺银。我自己的话就没那么高远的志向。 而且因为经常深夜cf，学习还是受到了很大的影响。譬如我已经心有余而力不足的高数。我又想出国，需要绩点，比赛奖项倒不是什么重要的。 思考的过程是痛苦的。好几个星期郁郁寡欢。最后还是舍不得过早离开热爱的ACM，最早应该也会在大三上退役。组女队的想法也还是一直都在，希望能在这项竞赛里发挥女孩子的长处。 大一学期期末的成绩除了高数，其他应该都还算不错了。camp的参加资格也拿到手。搬到校六的那天心情还是激动不已的。面对未知，我一向怀着憧憬和敬畏。 和婉乔相处得也还算融洽，都是温和的人，都会为对方去着想，日子自然也过得欢快。 坦白说，见识了人外有人，视野开拓了。平时说自闭的话也就是说说，其实心态一直都还好，毕竟cf打多了也就fo了。自闭是不可能自闭的。 我觉得camp最大的收获，是遇见了wls。 能想象么？越深入去读一个人，就越会被感动的感觉。读人大概是一项有趣的事业。报道的那天，wls来的还比较早，坐在我们后面和别人开始侃。一开始我以为是哪所高校的同学，对科技发展竟然这么有见地。后来教主来了，才知道是办camp的老师QAQ。 可巧，上一个这么敬仰的人也是交大的学长。似乎是和交大的不解之缘。 是啊，wls从来就不是一个乖孩子，打架，抑郁症，摔手机，性格暴躁，但是身处这样的环境小绵羊早就被吃掉了。 似乎是因为自己本身性格就比较随心所欲，所以就特别欣赏热血的人，会觉得畏畏缩缩让人不耐。wls办camp的初衷，就是为了发展弱校的ACM事业，给他们指一条路。没有人愿意投资，他就自己赔钱干。似乎是很久没见过这样善良的人了，看见大家为了自己的利益勾心斗角，踢皮球，渐渐地麻木了。wls的出现是一道光，愿将腰下剑，直为斩楼兰。 而且wls本身是个很有意思的人。其实很难想象他曾经有过心理疾病。他看起来，比任何人都能自得其乐。就是一个小小的马玩偶，都能玩得不亦乐乎。他总是对着我们微笑，惯于自黑，想把正能量带给我们。 真的很开心能与wls相遇在这个冬天。天很冷，心却被温暖了。坚持的一切似乎有了答案。 我只是做了我觉得对的事情，仅此而已。 过去未去，而未来已到。与其局限于眼前的琐碎，不如去勇敢畅想未来。视野决定成败。 如果说一年里进入东秦是幸运的，麻雀虽小五脏俱全。东秦给了我很多高校无法给予的机会。那么最幸运的莫过于在东秦，一个冬天，遇见wls。然后知道了什么叫希望。 明年的比赛很多，能否抓住机会，就看寒假能不能沉下心来。不去想，不去懊恼，只管风雨兼程。许个愿吧，参加女生赛，然后出师大捷。人生的起点，刚刚开始呢。加油加油，去做想做的事，去见喜欢的人。","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"新年","slug":"新年","permalink":"/tags/新年/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"CCPC Wannafly winter camp day1","slug":"CCPC-Wannafly-winter-camp-day1","date":"2019-01-20T15:04:07.000Z","updated":"2020-02-12T05:30:39.099Z","comments":true,"path":"2019/01/20/CCPC-Wannafly-winter-camp-day1/","link":"","permalink":"/2019/01/20/CCPC-Wannafly-winter-camp-day1/","excerpt":"well爆零了 蒟蒻本质暴露无遗 wls说是最简单的一场……然而我感受到满满恶意","text":"well爆零了 蒟蒻本质暴露无遗 wls说是最简单的一场……然而我感受到满满恶意 CCPC Wannafly winter camp day1A.机器人大佬队友出的题，debug过程万分艰辛。 首先要记录是否经过B区的点以及构造的矩形（或线段）的边长范围。特判输出0的情况：只需经过原点。接下来找到包含所需经过的点的最近转折点，需要注意如果s游离在外面，需要把范围扩到s点。分类如果经过B区，则相减加k并乘2；若无，则直接乘2。 的确不太复杂。主要是别遗漏就好。 B.吃豆豆 C.拆拆拆数我们想构造来着……然后，咕了。 用队友的思想，最后问题只需要简化成如何找出利用哥德巴赫猜想把偶数拆成两个素数的规律。事实证明，不存在的。暴力骗过都比天马行空要强…… 隔壁队的暴力思想大概是先把两组拆成相近的，然后先给一组加加减减，如果已经达到二十次还没有实现的话，再让另一组一起动……我一度觉得很神奇，不知道有没有理解错他们的意思。 然后我知道了比较靠谱的方法就是用小素数去凑。行吧，流下了不学无术的泪水。 D.超难的数学题听wls一席话，胜读十年书QAQ 先假定a/b，解方程（a+c)/(b+c)=p。若不可解，则继续寻找下一个a/b。 emmm还是有点懵，不懂a和b如何选定，还是只是随机的。 E.流流流动熟悉的配方，3n+1猜想。i最后一定得1。 然后dp一下。没有写具体的就是证明我不太会，以后一定填坑（自闭 F.爬爬爬山这是我唯一动手写了两个小时的题目，乱交不WA我还WA谁？ 第一反应是借用有代价的最短路的dp。但是没办法想通挖山这块的问题。 听了思路应该是第一座山的高度+k以上高度的山要看看是否挖,但是同学画的那张图我看不懂…… G.双重矩阵若超过n，则可说明x轴，y轴均可被覆盖。 好像就有某种神奇的规律…… H.我爱割葱原来“割葱”是睡觉的意思呀（浙江各地方言千奇百怪 从下往上切葱,找出最小的直接切就完事了 是我理解的太简单了吗？为什么没有看这道题…… I.起起落落反着找转折点 J.奇宝夺兵队友想用贪心，但思路卡在若选宝物最多的人的宝物，从而导致他不是最多的了，则会影响整个结果…… K.星球大战 以上欠的坑等我学成归来再填吧。知识盲点太多了……有点自闭。","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"camp","slug":"camp","permalink":"/tags/camp/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"Codeforces Round #525 (Div. 2)","slug":"Codeforces-Round-525-Div-2","date":"2018-12-05T13:01:08.000Z","updated":"2020-02-12T06:31:23.427Z","comments":true,"path":"2018/12/05/Codeforces-Round-525-Div-2/","link":"","permalink":"/2018/12/05/Codeforces-Round-525-Div-2/","excerpt":"QAQ自闭场 在升到1400越走越远","text":"QAQ自闭场 在升到1400越走越远 Codeforces Round #525 (Div. 2)由于早上搭博搭到三点的原因，所以昨晚打比赛的时候昏昏沉沉的。直接就导致了我感觉那些英语单词在眼前飘着就过去了，根本没办法翻译它们……不罗嗦了，直接进入题解部分吧 A. Ehab and another construction problemA题大意就是说给你一个数x，要求找到两个数a和b，使得a,b取值范围[1,x]，且a是b的倍数，a*b大于x，a/b小于x。 一开始我读不进去题，没注意到a，b要倍数关系，稀里糊涂交了一发。 但是其实题目还是很简单的。只要构造a=b=x，问题迎刃而解。值得注意的是，x=1时应该无解，故特判输出-1. B. Ehab and subtraction看B看了好久，没找到思路。 题目大意就是给出数组。每次找出其中非0的最小数输出，然后每个数减去这个数，直到做了k次操作。 后来盯着样例看了一会儿，灵光乍现！不就是给出的数列排序去重以后的差值依次输出么？超出了以后就一直输出0。 C. Ehab and a 2-operation task做这题的时候剩一个小时。其实正常情况这道题可以写出来的，难度着实不大。 我昨晚最后的思路就是i从最后一个数开始，加到离的最近的 i的倍数，最多只需要n次操作。最后一步就是全体取模n，使得结果从0到n-1排列。 但是忘记输出组数了……就说凭什么样例WA我三次。但是其实这个应该也过不了，x有大小限制，应该会爆。 去看了正解。QAQ巨简单。就是说每个数都加上5e5+10（也不一定，只是代表一个大数），后面n次。从1开始到n对a[i]-i+1取余，就能保证严格递增了。呜呜呜，应该能想到的，并不复杂。","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"CF","slug":"CF","permalink":"/tags/CF/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"图灵杯总结","slug":"图灵杯总结","date":"2018-12-04T09:20:10.000Z","updated":"2020-02-12T05:56:09.596Z","comments":true,"path":"2018/12/04/图灵杯总结/","link":"","permalink":"/2018/12/04/图灵杯总结/","excerpt":"待到秋来九月八，我花开后百花杀 12月2日。阴，有时有雨。 走进科技楼前顺手拍了一张照片 嗯 大雾 蛮符合心境的 有点迷茫，永远找不到前路在何方的感觉","text":"待到秋来九月八，我花开后百花杀 12月2日。阴，有时有雨。 走进科技楼前顺手拍了一张照片 嗯 大雾 蛮符合心境的 有点迷茫，永远找不到前路在何方的感觉 图灵杯总结一天前的广工赛其实打得蛮开心的，出了八题。虽然后来发现暴露出来的问题跟图灵杯差不多 上楼就遇到昕怡学姐了。非常感谢她赛前教的小技巧。虽然这次oj貌似没大崩，至少比赛的时候想到她的小tip，心态就还行 坐到位置上以后，听说可以测试一下运行环境，就顺手把模板打出来了，为下面节省了一点时间（然而这点小时间并没啥卵用 就图个心安 接下去一点时间看了一下板子 特别是平时经常用的高精度相关 一般来说，开始的时候我都是比较有优势的。以前切的水题比较多，拿到题一般就能判断是不是能轻松AC了。所以一开始遥遥领先是意料之中。但是一般到第三四题就会开始掉，一个主要原因是因为准确率开始滑了：本来性格一直就挺粗心的，不是读错题就是没看到细节；然后又太急，最后一发发的罚时算上去反而得不偿失。另一个原因可能是会怕难题：比如说之前见过类似的，不会写；那么比赛的时候不管我能不能写出来，我都会觉得自己死定了，肯定不会啊。大概跟平时写题没有即使补题的不良习惯有关，所以也是花了两天搭这个博客的意义，希望平时能养成做题反思的习惯。 封榜前还剩两题，看了下排名，好像第七。接下去就到了做不出题自闭的阶段了。结束的最后一秒更了一下榜，滑到第九了。后来因为数据的原因有道题重判了，掉成了十二名。拿了个三等奖完事儿了。 本来是冲着二等和最佳来的，结果都没有捧到。那天还是有点小小失落的吧。后来想了想，也没什么。比起以后全国赛里的丢牌，这只是小小的挫折了。也算是个勉励吧。现在还太菜，脚步不能停。 然后对着题榜总结一下自己每道题的思路吧 A题类似于脑筋急转弯，直接读入两个字符串然后依次分类讨论一下就好了，应该是签到题 B题看到最大公约数然后又是从1开始的话，答案一下子就出来了。罚时一发我记得是因为每组数据最后忘记换行了（吐血，这种错误已经犯得得心应手了）。没有先做好像是因为发现G更水，应该是吧。后来看他们过的那么快，在C上WA了一次就来写这题了 C题用个结构体排序很简单的。至于为啥又罚时了……第一次先按战斗值给武士排的序，再按金钱……后来发现应该先排钱少的（我大概是白痴吧） D题我WA了五发（成功从同题数排名前端掉到后端）。原因出在前导零，第一二次审题没看到；第三次忽略了全是零的情况；第四次以为是所有零都要删掉（全是零除外）；第五次莫名其妙又交了一发QAQ……第五次已经不抱希望对了，结果……过的那刻整个人都已经崩溃边缘了，心态被搞得有点瘫痪 E题以为是潘骏出的……刚开始以为是不是找规律，后来想到打表再去搞的时候已经放弃了 F题 我的想法是不断递归然后使用类似二分的思想。但是我的递归一直写的不太好。这次写了半个小时还是有bug，最后也就放弃了。看了标准代码有点简单，难点应该在思维上。想清楚从左往右推进就好了 G题类似于CF的水题吧。CF的水题写的比较多，然后交完A以后一下子就直奔写了这题。太简单了，就不讲了 H题一开始我没信心，后来发现过的人也不少以后就知道是规律题。第一次自己画了一下是 2 4 8 14，但是由于不相信自己，还是先用2的次方试了一下（顺便打了快速幂的板子），WA了一发。然后根据 2 4 8 14推规律，当然没有标准答案归纳的那么好，我觉得是他们的差值是等差数列，然后直接乘完相加。怕数据大了还用了快乘法（其实没必要）。后来听学长说取模都是放着看看的（微笑） 应该说上周的两场比赛也让我更加清楚自己的长短处，还有离梦想有多远。但是我也相信“待到秋来九月八，我花开后百花杀”，有了这份信念，支撑着在这条路走下去的应该不仅仅是一开始懵懵懂懂的追随了。未来会更好的，嗯，我愿意去相信。这周的PAT考试加油叭！","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"比赛总结","slug":"比赛总结","permalink":"/tags/比赛总结/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}